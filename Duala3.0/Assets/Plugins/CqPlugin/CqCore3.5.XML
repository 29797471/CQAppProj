<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CqCore3.5</name>
    </assembly>
    <members>
        <member name="T:SingletonMgr`1">
            <summary>
            单例管理类
            </summary>
        </member>
        <member name="M:SingletonMgr`1.#ctor">
            <summary>
            不应由反射来调用构造
            </summary>
        </member>
        <member name="T:CqCore.Causality`2">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="M:CqCore.Causality`2.#ctor(System.Func{`0,`1})">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="M:CqCore.Causality`2.Call(`0)">
            <summary>
            获得处理结果
            有计算过:直接返回结果
            没有计算过:计算结果,存储,并返回
            </summary>
        </member>
        <member name="T:CqCore.Causality`3">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="T:CqCore.Causality1_3Async`4">
            <summary>
            异步处理数据,缓存处理结果<para/>
            保证同一内容只处理一次,不会重复处理<para/>
            异步因果关系(同样的因得同样的果)<para/>
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理<para/>
            </summary>
        </member>
        <member name="M:CqCore.Causality1_3Async`4.#ctor(System.Action{`0,System.Action{`1,`2,`3}})">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="M:CqCore.Causality1_3Async`4.CallAsync(`0,System.Action{`1,`2,`3})">
            <summary>
            异步获得结果<para/>
            如果没有处理过,则开始处理,完成后回调<para/>
            如果正在处理中,则等到完成后回调<para/>
            如果已经完成处理过,则直接返回之前处理的结果
            </summary>
        </member>
        <member name="M:CqCore.Causality1_3Async`4.Clear">
            <summary>
            清除
            </summary>
        </member>
        <member name="T:CqCore.Causality1_2Async`3">
            <summary>
            异步处理数据,缓存处理结果<para/>
            保证同一内容只处理一次,不会重复处理<para/>
            异步因果关系(同样的因得同样的果)<para/>
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理<para/>
            </summary>
        </member>
        <member name="M:CqCore.Causality1_2Async`3.#ctor(System.Action{`0,System.Action{`1,`2}})">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="M:CqCore.Causality1_2Async`3.CallAsync(`0,System.Action{`1,`2})">
            <summary>
            异步获得结果<para/>
            如果没有处理过,则开始处理,完成后回调<para/>
            如果正在处理中,则等到完成后回调<para/>
            如果已经完成处理过,则直接返回之前处理的结果
            </summary>
        </member>
        <member name="M:CqCore.Causality1_2Async`3.Clear">
            <summary>
            清除
            </summary>
        </member>
        <member name="T:CqCore.CausalityAsync`2">
            <summary>
            异步处理数据,缓存处理结果<para/>
            保证同一内容只处理一次,不会重复处理<para/>
            异步因果关系(同样的因得同样的果)<para/>
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理<para/>
            </summary>
        </member>
        <member name="M:CqCore.CausalityAsync`2.#ctor(System.Action{`0,System.Action{`1}})">
            <summary>
            因果关系(同样的因得同样的果)
            通过一个外部定义的函数,来完成执行,记录执行结果,下次同样的参数传入不再处理
            </summary>
        </member>
        <member name="M:CqCore.CausalityAsync`2.CallAsync(`0,System.Action{`1})">
            <summary>
            异步获得结果<para/>
            如果没有处理过,则开始处理,完成后回调<para/>
            如果正在处理中,则等到完成后回调<para/>
            如果已经完成处理过,则直接返回之前处理的结果
            </summary>
        </member>
        <member name="M:CqCore.CausalityAsync`2.Call(`0)">
            <summary>
            对获取过的key同步获得结果
            </summary>
        </member>
        <member name="M:CqCore.CausalityAsync`2.Clear">
            <summary>
            清除
            </summary>
        </member>
        <member name="T:CqCore.Causality2_1`3">
            <summary>
            因果关系<para/>
            2输入1输出
            </summary>
        </member>
        <member name="M:CqCore.Causality2_1`3.#ctor">
            <summary>
            双键字典
            </summary>
        </member>
        <member name="P:CqCore.Causality2_1`3.Item(`0,`1)">
            <summary>
            由双键获取值
            </summary>
        </member>
        <member name="M:CqCore.Causality2_1`3.ContainsKey(`0,`1)">
            <summary>
            是否有这个双键映射
            </summary>
        </member>
        <member name="M:CqCore.Causality2_1`3.Clear">
            <summary>
            清除
            </summary>
        </member>
        <member name="T:CqCore.Arithmetic">
            <summary>
            绝对值运算
            </summary>
            <summary>
            函数表达式解析
            </summary>
            <summary>
            三角函数运算
            </summary>
            <summary>
            基本运算(不含括号,三角函数,绝对值)
            </summary>
        </member>
        <member name="F:CqCore.Arithmetic.absPattern">
            <summary>
            获取绝对值符号,不能有嵌套
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.AbsExpr(System.String,System.Collections.Generic.Dictionary{System.String,System.Func{System.Object}})">
            <summary>
            带绝对值的表达式函数
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.Parse_FxWithEqual(System.String)">
            <summary>
            包含条件运算符的函数
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.Parse_Fx(System.String)">
            <summary>
            表达式中的x代表第一个参数
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.Parse_Fabt(System.String)">
            <summary>
            表达式中的x代表第一个参数
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.Parse_Fθ(System.String)">
            <summary>
            表达式中的θ代表第一个参数
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.ExpressionParser(System.String)">
            <summary>
            解析一个表达式,返回函数<para/>
            函数调用时第一个参数会替换表达式中的变量a<para/>
            函数调用时第一个参数会替换表达式中的变量b<para/>
            函数调用时第一个参数会替换表达式中的变量c
            </summary>
        </member>
        <member name="F:CqCore.Arithmetic.parenthesisPattern">
            <summary>
            获取最里层的带括号的相关运算符：三角函数,符号运算符,括号
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.ParExpr(System.String,System.Collections.Generic.Dictionary{System.String,System.Func{System.Object}})">
            <summary>
            带括号的表达式(sign,sin,arcsin,arcsin,cos,arccos,tan,arctan)
            </summary>
        </member>
        <member name="F:CqCore.Arithmetic.matchX">
            <summary>
            匹配成(数字/变量,运算符,数字/变量,...,运算符,数字/变量)
            </summary>
        </member>
        <member name="M:CqCore.Arithmetic.BaseExpr(System.String,System.Collections.Generic.Dictionary{System.String,System.Func{System.Object}})">
            <summary>
            由基本的中缀表达式得到一个函数
            </summary>
        </member>
        <member name="T:CqCore.ArithmeticCalc">
            <summary>
            存储运算符信息
            </summary>
        </member>
        <member name="T:CqCore.CalcEnumAttribute">
            <summary>
            定义一个枚举值的属性标签
            </summary>
        </member>
        <member name="F:CqCore.CalcEnumAttribute.pri">
            <summary>
            优先级
            </summary>
        </member>
        <member name="F:CqCore.CalcEnumAttribute.op">
            <summary>
            运算符
            </summary>
        </member>
        <member name="F:CqCore.CalcEnumAttribute.swap">
            <summary>
            可交换
            </summary>
        </member>
        <member name="F:CqCore.CalcEnumAttribute.methodName">
            <summary>
            编译器将操作符转换的反射调用函数名称
            </summary>
        </member>
        <member name="T:CqCore.EnumColorAttribute">
            <summary>
            定义一个枚举值的属性标签
            </summary>
        </member>
        <member name="F:CqCore.EnumColorAttribute.htmlColor">
            <summary>
            颜色名称
            </summary>
        </member>
        <member name="M:CqCore.EnumColorAttribute.#ctor(System.String)">
            <summary>
            定义一个枚举值的颜色属性标签#09009
            </summary>
        </member>
        <member name="T:CqCore.EnumLabelAttribute">
            <summary>
            定义一个枚举值的属性标签
            </summary>
        </member>
        <member name="F:CqCore.EnumLabelAttribute.name">
            <summary>
            名称
            </summary>
        </member>
        <member name="M:CqCore.EnumLabelAttribute.#ctor(System.String,System.Type[])">
            <summary>
            定义一个枚举值的属性标签
            </summary>
        </member>
        <member name="T:CqCore.MemberSeparatorAttribute">
            <summary>
            定义一个数据结构在表格中被序列化时的成员分隔符
            </summary>
        </member>
        <member name="F:CqCore.MemberSeparatorAttribute.separator">
            <summary>
            成员分隔符名称
            </summary>
        </member>
        <member name="M:CqCore.MemberSeparatorAttribute.#ctor(System.String)">
            <summary>
            定义一个枚举值的属性标签
            </summary>
        </member>
        <member name="T:CqCore.FieldAttribute">
            <summary>
            修饰字段的标签基类
            </summary>
        </member>
        <member name="P:CqCore.FieldAttribute.Target">
            <summary>
             字段值
            </summary>
        </member>
        <member name="T:CqCore.IMemberAttribute">
            <summary>
            成员属性接口
            </summary>
        </member>
        <member name="M:CqCore.IMemberAttribute.SetTarget(System.Reflection.MemberInfo,System.Object)">
            <summary>
            由此传入成员的父对象和成员相关信息
            </summary>
        </member>
        <member name="T:CqCore.LinkMemberAttribute">
            <summary>
            关联同对象下另一属性或者一个固定值
            </summary>
        </member>
        <member name="M:CqCore.LinkMemberAttribute.PropertyChanged_CallBack(System.Action{System.Object},CqCore.ICancelHandle,System.Boolean)">
            <summary>
            链接的另一个数据改变
            </summary>
        </member>
        <member name="F:CqCore.LinkMemberAttribute.convertFunc">
            <summary>
            依赖数据转换函数
            </summary>
        </member>
        <member name="F:CqCore.LinkMemberAttribute.defaultConvert">
            <summary>
            默认的依赖数据转换函数
            </summary>
        </member>
        <member name="M:CqCore.LinkMemberAttribute.ConvertTo(System.Object)">
            <summary>
            转换函数
            </summary>
        </member>
        <member name="T:CqCore.LinkMethodAttribute">
            <summary>
            链接所在对象的一个方法
            </summary>
        </member>
        <member name="T:CqCore.MemberAttribute">
            <summary>
            修饰类成员的特性
            </summary>
        </member>
        <member name="T:CqCore.MethodAttribute">
            <summary>
            修饰方法的特性
            </summary>
        </member>
        <member name="T:CqCore.LinkPropertyAttribute">
            <summary>
            修饰一个属性,并提供一个数据或者关联同对象下的另一个属性
            </summary>
        </member>
        <member name="M:CqCore.LinkPropertyAttribute.LinkPropertyChanged_CallBack(System.Action{System.Object},CqCore.ICancelHandle,System.Boolean)">
            <summary>
            链接的另一个数据改变
            返回移除链接的方法
            </summary>
        </member>
        <member name="P:CqCore.LinkPropertyAttribute.Data">
            <summary>
            另一个属性值
            </summary>
        </member>
        <member name="F:CqCore.LinkPropertyAttribute.convertMethod">
            <summary>
            依赖数据转换函数
            </summary>
        </member>
        <member name="F:CqCore.LinkPropertyAttribute.arg0">
            <summary>
            转换函数参数
            </summary>
        </member>
        <member name="M:CqCore.LinkPropertyAttribute.ConvertTo(System.Object)">
            <summary>
            转换函数
            </summary>
        </member>
        <member name="T:CqCore.PropertyAttribute">
            <summary>
            修饰属性的标签基类
            </summary>
        </member>
        <member name="M:CqCore.PropertyAttribute.PropertyChanged_CallBack(System.Action,CqCore.ICancelHandle,System.Boolean)">
            <summary>
            监听标签修饰的对象改变,返回移除函数
            </summary>
        </member>
        <member name="P:CqCore.PropertyAttribute.Target">
            <summary>
            属性值
            </summary>
        </member>
        <member name="T:CqCore.ObjectAttribute">
            <summary>
            修饰类/结构的特性
            </summary>
        </member>
        <member name="P:CqCore.ObjectAttribute.Target">
            <summary>
            对象
            </summary>
        </member>
        <member name="T:CqCore.Digraph">
            <summary>
            有向图
            </summary>
        </member>
        <member name="M:CqCore.Digraph.FindMinWeightWay(CqCore.MapPoint,CqCore.MapPoint)">
            <summary>
            找寻一条最短路径
            </summary>
        </member>
        <member name="F:CqCore.Way.weight">
            <summary>
            权重
            </summary>
        </member>
        <member name="T:CqCore.NumberAxis">
            <summary>
            数轴
            </summary>
        </member>
        <member name="M:CqCore.NumberAxis.InverseNumber">
            <summary>
            逆序数
            </summary>
        </member>
        <member name="T:CqCore.SquareMatrix">
            <summary>
            方阵
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.#ctor(System.Int32)">
            <summary>
            方阵
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            方阵
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.Determinant">
            <summary>
            递归计算行列式的值
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.Unit(System.Int32)">
            <summary>
            单位方阵
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.Inverse">
            <summary>
            求矩阵的逆矩阵
            </summary>
        </member>
        <member name="M:CqCore.SquareMatrix.AdjointMatrix">
            <summary>
            计算方阵的伴随矩阵
            </summary>
        </member>
        <member name="T:CqCore.AsyncReturn`1">
            <summary>
            主要用于提供给协程函数,传递返回值<para/>
            由于协程无法参数传递ref,out,导致无法返回结果
            </summary>
        </member>
        <member name="T:CqCore.GlobalCoroutine">
            <summary>
            全局协程操作类<para/>
            </summary>
            <summary>
            全局协程操作类
            </summary>
            <summary>
            全局协程操作类
            </summary>
        </member>
        <member name="F:CqCore.GlobalCoroutine.recordStacktrace">
            <summary>
            记录协程启动时的堆栈,便于定位代码
            </summary>
        </member>
        <member name="P:CqCore.GlobalCoroutine.CqCoroutineCount">
            <summary>
            当前协程数量
            </summary>
        </member>
        <member name="P:CqCore.GlobalCoroutine.deltaTime">
            <summary>
            每帧时差,用于驱动协程执行<para/>
            对于Unity运行时这个值等于Time.deltaTime
            </summary>
        </member>
        <member name="F:CqCore.GlobalCoroutine.tick_seconds_scale">
            <summary>
            1秒等于10^7tcik
            </summary>
        </member>
        <member name="P:CqCore.GlobalCoroutine.Tick">
            <summary>
            1970-1-1至今的tick
            </summary>
        </member>
        <member name="P:CqCore.GlobalCoroutine.deltaTick">
            <summary>
            每帧的tick增量
            </summary>
        </member>
        <member name="F:CqCore.GlobalCoroutine._Update">
            <summary>
            直接将对象的成员函数添加到委托会形成托管堆,带来比较高的gc.
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Update(System.Int64)">
            <summary>
            每帧调用一次,传入tick
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.StopAllCoroutines">
            <summary>
            停止当前所有协程
            </summary>
        </member>
        <member name="F:CqCore.GlobalCoroutine.GetCurrentToWaitFor">
            <summary>
            自定义接协程返回对象作等待的处理            <para/>
            1.返回int 等待x帧                        <para/>
            2.返回float 等待x秒                      <para/>
            3.返回null 等待1帧                       <para/>
            4.返回WaitForFrames 等待x帧
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Define_GetCurrentToWaitFor(System.Func{System.Object,System.Object})">
            <summary>
            自定义接协程返回对象作等待的处理            <para/>
            1.返回int 等待x帧                        <para/>
            2.返回float 等待x秒                      <para/>
            3.返回null 等待1帧                       <para/>
            4.返回WaitForFrames 等待x帧
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.GetTickTime(System.Single)">
            <summary>
            获取经过seconds秒后的最新时刻tick
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.GetSpanTick(System.Single)">
            <summary>
            获取一段时间对应的tick长度
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.ToSeconds(System.Int64)">
            <summary>
            获取时刻tick对应的剩余秒数
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Start(System.Collections.IEnumerator,CqCore.ICancelHandle,System.Action)">
            <summary>
            执行一个协同程序,支持嵌套<para/>
            yield return null;表示等1帧
            </summary>
            <param name="iterator">传入一个协程执行函数的调用</param>
            <param name="handle">终止这个协程执行的外部操作句柄</param>
            <param name="OnComplete">当协程执行完成后回调</param>
        </member>
        <member name="M:CqCore.GlobalCoroutine.ThreadPoolCall(System.Action)">
            <summary>
            从协程中切换到线程池中的一个线程执行委托,并等待完成后返回
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Call(System.Action,CqCore.ICancelHandle)">
            <summary>
            将委托添加主线程中,由update驱动执行<para/>
            对于unity项目同时兼容编辑器环境和运行环境
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.DelayCall(System.Single,System.Action,CqCore.ICancelHandle)">
            <summary>
            延迟second秒后,执行action
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.DelayCall(System.Int32,System.Action,CqCore.ICancelHandle)">
            <summary>
            延迟frames帧后,执行action
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.LoopCall(System.Single,System.Action,CqCore.ICancelHandle)">
            <summary>
            每second秒后,执行action
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.LoopCall(System.Int32,System.Action,CqCore.ICancelHandle)">
            <summary>
            每frames帧后,执行action
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.BlockingCall(System.Collections.IEnumerator)">
            <summary>
            像普通函数一样执行协程,忽视所有协程内部的返回,直到函数退出。
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Sleep(System.Single)">
            <summary>
            协程等待一段时间(seconds秒)
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Sleep(System.Single,CqCore.AsyncReturn{System.Single})">
            <summary>
            协程等待一段时间(seconds秒),可动态调整速度来减少等待时间.
            </summary>
        </member>
        <member name="M:CqCore.GlobalCoroutine.Sleep(System.Int32)">
            <summary>
            协程等待一段时间(frames帧)
            </summary>
        </member>
        <member name="M:CqCore.ZipHelperX.ZipFileDirectory(System.String,System.String,System.String[],System.String[],System.String,CqCore.ZipHelperX.CompressLevel)">
            <summary>
            压缩多层目录
            </summary>
        </member>
        <member name="M:CqCore.ZipHelperX.ZipSetp(System.String,System.String,System.String[],System.String[],ICCEmbedded.SharpZipLib.Zip.ZipOutputStream,ICCEmbedded.SharpZipLib.Checksum.Crc32)">
            <summary>
            递归遍历目录
            </summary>
        </member>
        <member name="M:CqCore.ZipHelperX.UnZip(System.String,System.String,System.Action{System.Single},System.IO.Stream)">
            <summary>
            解压功能(解压压缩文件到指定目录)
            </summary>
            <param name="FileToUpZip">待解压的文件</param>
            <param name="ZipedFolder">指定解压目标目录</param>
            <param name="UnZipProgress">解压进度</param>
            <param name="memStream">解压流</param>
        </member>
        <member name="T:CqCore.ZipUtility">
            <summary>
            Zip包的压缩与解压
            </summary>
        </member>
        <member name="M:CqCore.ZipUtility.ZipCallback.OnPreZip(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            压缩单个文件或文件夹前执行的回调
            </summary>
            <param name="_entry"></param>
            <returns>如果返回true，则压缩文件或文件夹，反之则不压缩文件或文件夹</returns>
        </member>
        <member name="M:CqCore.ZipUtility.ZipCallback.OnPostZip(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            压缩单个文件或文件夹后执行的回调
            </summary>
            <param name="_entry"></param>
        </member>
        <member name="M:CqCore.ZipUtility.ZipCallback.OnFinished(System.Boolean)">
            <summary>
            压缩执行完毕后的回调
            </summary>
            <param name="_result">true表示压缩成功，false表示压缩失败</param>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipCallback.OnPreUnzip(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            解压单个文件或文件夹前执行的回调
            </summary>
            <param name="_entry"></param>
            <returns>如果返回true，则压缩文件或文件夹，反之则不压缩文件或文件夹</returns>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipCallback.OnPostUnzip(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            解压单个文件或文件夹后执行的回调
            </summary>
            <param name="_entry"></param>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipCallback.OnFinished(System.Boolean)">
            <summary>
            解压执行完毕后的回调
            </summary>
            <param name="_result">true表示解压成功，false表示解压失败</param>
        </member>
        <member name="M:CqCore.ZipUtility.Zip(System.String[],System.String,System.String,CqCore.ZipUtility.ZipCallback)">
            <summary>
            压缩文件和文件夹
            </summary>
            <param name="_fileOrDirectoryArray">文件夹路径和文件名</param>
            <param name="_outputPathName">压缩后的输出路径文件名</param>
            <param name="_password">压缩密码</param>
            <param name="_zipCallback">ZipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipFile(System.String,System.String,System.String,CqCore.ZipUtility.UnzipCallback)">
            <summary>
            解压Zip包
            </summary>
            <param name="_filePathName">Zip包的文件路径名</param>
            <param name="_outputPath">解压输出路径</param>
            <param name="_password">解压密码</param>
            <param name="_unzipCallback">UnzipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipFile(System.Byte[],System.String,System.String,CqCore.ZipUtility.UnzipCallback)">
            <summary>
            解压Zip包
            </summary>
            <param name="_fileBytes">Zip包字节数组</param>
            <param name="_outputPath">解压输出路径</param>
            <param name="_password">解压密码</param>
            <param name="_unzipCallback">UnzipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipUtility.UnzipFile(System.IO.Stream,System.String,System.String,CqCore.ZipUtility.UnzipCallback)">
            <summary>
            解压Zip包
            </summary>
            <param name="_inputStream">Zip包输入流</param>
            <param name="_outputPath">解压输出路径</param>
            <param name="_password">解压密码</param>
            <param name="_unzipCallback">UnzipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipUtility.ZipFile(System.String,System.String,ICCEmbedded.SharpZipLib.Zip.ZipOutputStream,CqCore.ZipUtility.ZipCallback)">
            <summary>
            压缩文件
            </summary>
            <param name="_filePathName">文件路径名</param>
            <param name="_parentRelPath">要压缩的文件的父相对文件夹</param>
            <param name="_zipOutputStream">压缩输出流</param>
            <param name="_zipCallback">ZipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipUtility.ZipDirectory(System.String,System.String,ICCEmbedded.SharpZipLib.Zip.ZipOutputStream,CqCore.ZipUtility.ZipCallback)">
            <summary>
            压缩文件夹
            </summary>
            <param name="_path">要压缩的文件夹</param>
            <param name="_parentRelPath">要压缩的文件夹的父相对文件夹</param>
            <param name="_zipOutputStream">压缩输出流</param>
            <param name="_zipCallback">ZipCallback对象，负责回调</param>
            <returns></returns>
        </member>
        <member name="T:CqCore.ZipHelper">
             <summary>
             Zip压缩帮助类
            
             修改纪录
            
                    2015-09-16  版本：1.0 YangHengLian 创建主键，注意命名空间的排序。
                 2016-5-7 YangHengLian增加了可以支持多个文件或者多个文件夹打包成一个zip文件
             
             版本：1.0
            
             <author>
                    <name>YangHengLian</name>
                    <date>2015-09-16</date>
             </author>
             </summary>
        </member>
        <member name="M:CqCore.ZipHelper.UnZip(System.String,System.String)">
            <summary>  
            功能：解压zip格式的文件。  
            </summary>  
            <param name="zipFilePath">压缩文件路径</param>  
            <param name="unZipDir">解压文件存放路径,为空时默认与压缩文件同一级目录下，跟压缩文件同名的文件夹</param>  
            <returns>解压是否成功</returns>  
        </member>
        <member name="M:CqCore.ZipHelper.ZipFile(System.String,System.String,System.Int32)">
            <summary>
            压缩单个文件
            </summary>
            <param name="filePath">被压缩的文件名称(包含文件路径)，文件的全路径</param>
            <param name="zipedFileName">压缩后的文件名称(包含文件路径)，保存的文件名称</param>
            <param name="compressionLevel">压缩率0（无压缩）到 9（压缩率最高）</param>
        </member>
        <member name="M:CqCore.ZipHelper.ZipFile(System.String,System.String)">
            <summary> 
            压缩单个文件 
            </summary> 
            <param name="fileToZip">要进行压缩的文件名，全路径</param> 
            <param name="zipedFile">压缩后生成的压缩文件名,全路径</param> 
        </member>
        <member name="M:CqCore.ZipHelper.ZipManyFilesOrDictorys(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            压缩多个目录或文件
            </summary>
            <param name="folderOrFileList">待压缩的文件夹或者文件，全路径格式,是一个集合</param>
            <param name="zipedFile">压缩后的文件名，全路径格式</param>
            <param name="password">压宿密码</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipHelper.ZipFileWithStream(System.String,ICCEmbedded.SharpZipLib.Zip.ZipOutputStream)">
            <summary>
            带压缩流压缩单个文件
            </summary>
            <param name="fileToZip">要进行压缩的文件名</param>
            <param name="zipStream"></param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ZipHelper.ZipFileDictory(System.String,ICCEmbedded.SharpZipLib.Zip.ZipOutputStream,System.String)">
            <summary>
            递归压缩文件夹方法
            </summary>
            <param name="folderToZip"></param>
            <param name="s"></param>
            <param name="parentFolderName"></param>
        </member>
        <member name="M:CqCore.ZipHelper.ZipDir(System.String,System.String,System.Int32)">
            <summary>
            压缩文件夹
            </summary>
        </member>
        <member name="T:CqCore.CancelHandle">
            <summary>
            终止操作的句柄<para/>
            操作对象通过CancelAct+=添加撤销的操作<para/>
            管理对象通过CancelAll执行所有撤销操作并清除<para/>
            一般情况下不需要通过CancelAct-=取消撤销操作
            </summary>
        </member>
        <member name="M:CqCore.CancelHandle.CancelAll">
            <summary>
            执行通过CancelAct+=添加的所有操作<para/>
            完成后清除所有委托
            </summary>
        </member>
        <member name="T:CqCore.DelayHandle">
            <summary>
            延迟句柄
            </summary>
        </member>
        <member name="M:CqCore.DelayHandle.Immediately">
            <summary>
            立即执行
            </summary>
        </member>
        <member name="M:CqCore.DelayHandle.Cancel">
            <summary>
            取消执行
            </summary>
        </member>
        <member name="T:CqCore.ICancelHandle">
            <summary>
             表示对象可以派发取消事件<para/>
             部分逻辑可以监听取消事件阻止操作.
            </summary>
        </member>
        <member name="E:CqCore.ICancelHandle.CancelAct">
            <summary>
            通过+=注入取消时执行的回调<para/>
            当操作实例执行CancelAll后,所有操作都会被清除<para/>
            所以不需要定义-=
            </summary>
        </member>
        <member name="T:CqCore.QueueAction">
            <summary>
            按队列先后逐一处理事务
            </summary>
        </member>
        <member name="M:CqCore.QueueAction.#ctor">
            <summary>
            按队列先后逐一处理事务
            </summary>
        </member>
        <member name="P:CqCore.QueueAction.Doing">
            <summary>
            正在处理事务
            </summary>
        </member>
        <member name="M:CqCore.User32.WindowFromPoint(System.Int32,System.Int32)">
            <summary>
            由屏幕位置获取窗口
            </summary>
        </member>
        <member name="M:CqCore.User32.SetForegroundWindow(System.IntPtr)">
            <summary>
            将窗口置于前台
            </summary>
        </member>
        <member name="T:CqCore.DirOpr">
            <summary>
            文件夹操作类
            </summary>
        </member>
        <member name="M:CqCore.DirOpr.Delete(System.String)">
            <summary>
            删除文件夹
            </summary>
        </member>
        <member name="M:CqCore.DirOpr.ClearOrCreate(System.String)">
            <summary>
            清空文件夹
            </summary>
        </member>
        <member name="M:CqCore.DirOpr.Copy(System.String,System.String,System.Boolean,System.String)">
            <summary>
            复制文件夹到目标文件夹内
            </summary>
            <param name="srcDir">要复制的文件夹</param>
            <param name="dstDir">复制到的目标文件夹内</param>
            <param name="overwrite">发现文件相同是否覆盖</param>
            <param name="excludeExtensions">排除后缀名,形如:.meta|.bundle</param>
        </member>
        <member name="M:CqCore.DirOpr.Copy(System.String,System.String,System.Boolean,System.Predicate{System.String})">
            <summary>
            复制文件夹到目标文件夹内
            </summary>
            <param name="srcDir">要复制的文件夹</param>
            <param name="dstDir">复制到的目标文件夹内</param>
            <param name="overwrite">发现文件相同是否覆盖</param>
            <param name="excludeExtensions">排除后缀名,形如:.meta|.bundle</param>
        </member>
        <member name="M:CqCore.DirOpr.PreorderTraversal(System.String,System.Action{System.String})">
            <summary>
            遍历文件夹下所有文件(包含子文件夹下的文件)
            </summary>
            <param name="dirPath">文件夹路径</param>
            <param name="OnFile">回调子文件的相对路径</param>
        </member>
        <member name="M:CqCore.DirOpr.FindFile(System.String,System.Predicate{System.String})">
            <summary>
            先序遍历查找文件
            </summary>
        </member>
        <member name="M:CqCore.DirOpr.FindAll(System.Collections.Generic.List{System.String}@,System.String,System.Predicate{System.String},System.Predicate{System.String},System.Int32,System.Int32)">
            <summary>
            先序遍历查找匹配文件
            </summary>
            <param name="list"></param>
            <param name="dirPath"></param>
            <param name="OnFile"></param>
            <param name="OnFolder"></param>
            <param name="startDepth">起始搜索深度</param>
            <param name="endDepth">最大搜索深度</param>
        </member>
        <member name="M:CqCore.DirOpr.FindAllInDesk(System.Collections.Generic.List{System.String}@,System.Predicate{System.String},System.Predicate{System.String},System.Int32,System.Int32)">
            <summary>
            查找文件
            </summary>
            <param name="list"></param>
            <param name="OnFile"></param>
            <param name="OnFolder"></param>
            <param name="startDepth">盘符下起始目录等级(盘符下视为1级目录)</param>
            <param name="endDepth">盘符下起始startDepth级目录</param>
        </member>
        <member name="M:CqCore.DirOpr.GetFileSystemEntries(System.String,System.String)">
            <summary>
            返回指定目录中所有文件和子目录的名称。
            </summary>
        </member>
        <member name="T:CqCore.CqRequest">
            <summary>
            网络数据请求,返回类型T<para/>
            封装HttpWebRequest,WebRequest
            </summary>
        </member>
        <member name="M:CqCore.CqRequest.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32)">
            <summary>
            网络数据请求,返回类型T<para/>
            封装HttpWebRequest,WebRequest
            </summary>
        </member>
        <member name="M:CqCore.CqRequest.#ctor(System.Net.WebRequest)">
            <summary>
            网络数据请求,返回类型T<para/>
            封装HttpWebRequest,WebRequest
            </summary>
        </member>
        <member name="M:CqCore.CqRequest.SendAsync``1(CqCore.AsyncReturn{``0})">
            <summary>
            切换到非主线程中发起请求<para/>
            收到数据后在主线程中返回<para/>
            T:string 返回文本<para/>
            T:byte[] 返回数据流<para/>
            其它:将文本Torsion反序列化后输出
            </summary>
        </member>
        <member name="M:CqCore.CqRequest.Send``1">
            <summary>
            同步发送请求,返回数据<para/>
            T:string 返回文本<para/>
            T:byte[] 返回数据流<para/>
            其它:将文本Torsion反序列化后输出
            </summary>
        </member>
        <member name="M:CqCore.CqRequest.GetTextEncoder">
            <summary>
            获取返回内容的编码
            </summary>
        </member>
        <member name="M:CqCore.HttpUtil.CheckUrlVisit(System.String)">
            <summary>
            检查网站是否可以访问
            </summary>
        </member>
        <member name="M:CqCore.HttpUtil.OpenUrl(System.String,CqCore.HttpUtil.BrowserStyle)">
            <summary>
            调用系统默认的浏览器打开链接
            </summary>
        </member>
        <member name="M:CqCore.HttpUtil.DownloadFile(System.String,System.String)">
            <summary>
            下载文件到本地
            </summary>
        </member>
        <member name="M:CqCore.HttpUtil.DownloadFile(System.String,System.String,CqCore.AsyncReturn{System.Boolean})">
            <summary>
            再另一线程中下载完成后在主线程中返回
            </summary>
        </member>
        <member name="T:CqCore.P2PClient">
            <summary>
            P2P客户端
            1.向服务端注册
            2.p2p客户端通过服务端相互通信
            </summary>
        </member>
        <member name="F:CqCore.P2PClient.dic">
            <summary>
            当前所有的p2p客户端
            </summary>
        </member>
        <member name="E:CqCore.P2PClient.OnReceiveMsg">
            <summary>
            接收其他客户端发送的消息
            </summary>
        </member>
        <member name="E:CqCore.P2PClient.OnDisConnect">
            <summary>
            远程主机断开连接
            </summary>
        </member>
        <member name="M:CqCore.P2PClient.SendMsg(System.Int32,System.Object)">
            <summary>
            向其他p2p客户端通信
            </summary>
        </member>
        <member name="M:CqCore.P2PClient.Close">
            <summary>
            主动断开连接
            </summary>
        </member>
        <member name="T:CqCore.P2PServer">
            <summary>
            P2P服务端
            1.给连接的p2p客户端分配id
            2.维护所有P2P客户端列表
            3.提供p2p客户端相互通信
            </summary>
        </member>
        <member name="F:CqCore.P2PServer.regDic">
            <summary>
            注册了的p2p客户端列表
            </summary>
        </member>
        <member name="M:CqCore.P2PServer.ForEach(System.Action{CqCore.ObjClient})">
            <summary>
            遍历p2p客户端
            </summary>
        </member>
        <member name="T:CqCore.PingUtil">
            <summary>
            局域网遍历
            </summary>
        </member>
        <member name="M:CqCore.PingUtil.GetIPv4(System.String)">
            <summary>
            传入域名返回对应的数字IPv4
            </summary>
        </member>
        <member name="M:CqCore.PingUtil.GetIPv4(System.String,CqCore.AsyncReturn{System.String})">
            <summary>
            再另一线程中下载完成后在主线程中返回
            </summary>
        </member>
        <member name="T:CqCore.QClient">
            <summary>
            套接字客户端
            异步数据接收有可能收到的数据不是一个完整包，或者接收到的数据超过一个包的大小，
            因此我们需要把接收的数据进行缓存。
            异步发送我们也需要把每个发送的包加入到一个队列，然后通过队列逐个发送出去，
            如果每个都实时发送，有可能造成上一个数据包未发送完成，
            这时再调用SendAsync会抛出异常，提示SocketAsyncEventArgs正在进行异步操作，
            因此我们需要建立接收缓存和发送缓存。
            https://blog.csdn.net/snow_5288/article/details/72794306
            </summary>
        </member>
        <member name="E:CqCore.QClient.OnDisConnect">
            <summary>
            远程主机断开连接
            </summary>
        </member>
        <member name="M:CqCore.QClient.StartLoop">
            <summary>
            开启收发循环
            1.接收流数据到接收缓冲
            2.从发送缓冲发送数据到流
            </summary>
        </member>
        <member name="M:CqCore.QClient.Connect(System.String,System.Int32,System.Action{System.Boolean})">
            <summary>
            异步连接服务器
            </summary>
        </member>
        <member name="T:CqCore.ObjServer">
            <summary>
            T服务端
            </summary>
        </member>
        <member name="P:CqCore.ObjServer.List">
            <summary>
            连接的客户端列表
            </summary>
        </member>
        <member name="E:CqCore.ObjServer.OnAccept">
            <summary>
            当接入一个客户端时自动开启收发循环
            </summary>
        </member>
        <member name="T:CqCore.ObjClient">
            <summary>
            对象发送客户端
            </summary>
        </member>
        <member name="P:CqCore.ObjClient.RemoteEndPoint">
            <summary>
            远程终结点
            </summary>
        </member>
        <member name="P:CqCore.ObjClient.LocalEndPoint">
            <summary>
            本地终结点
            </summary>
        </member>
        <member name="E:CqCore.ObjClient.OnDisConnect">
            <summary>
            远程主机断开连接
            </summary>
        </member>
        <member name="E:CqCore.ObjClient.OnReceive">
            <summary>
            异步线程中获取到数据，业务逻辑切回自己的线程处理数据
            </summary>
        </member>
        <member name="M:CqCore.ObjClient.Connect(System.String,System.Int32,System.Action{System.Boolean})">
            <summary>
            异步连接服务器
            连接后开启收发循环
            </summary>
        </member>
        <member name="M:CqCore.ObjClient.StartLoop">
            <summary>
            开启循环从接收字节队列中转换成对象
            </summary>
        </member>
        <member name="M:CqCore.ObjClient.Send(System.Object)">
            <summary>
            发送数据对象
            </summary>
        </member>
        <member name="M:CqCore.ObjClient.Close">
            <summary>
            主动断开连接
            </summary>
        </member>
        <member name="T:CqCore.MemberProxy">
            <summary>
            对象成员代理类<para/>
            可对成员赋值和获取值
            </summary>
        </member>
        <member name="T:CqCore.MarkSerializeAttribute">
            <summary>
            修饰一个非泛型的普通类型,定义序列化时按成员属性或者字段来序列化
            </summary>
        </member>
        <member name="F:CqCore.MarkSerializeAttribute.style">
            <summary>
            定义对这个类型的序列化方式
            </summary>
        </member>
        <member name="M:CqCore.MarkSerializeAttribute.#ctor(CqCore.SerializeTypeStyle)">
            <summary>
            修饰一个非泛型的普通类型,定义序列化时按成员属性或者字段来序列化
            </summary>
            <param name="style">定义对这个类型的序列化方式</param>
        </member>
        <member name="T:CqCore.SerializeTypeStyle">
            <summary>
            类型序列化方式
            </summary>
        </member>
        <member name="F:CqCore.SerializeTypeStyle.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:CqCore.SerializeTypeStyle.Field">
            <summary>
            字段
            </summary>
        </member>
        <member name="F:CqCore.SerializeTypeStyle.Property">
            <summary>
            属性
            </summary>
        </member>
        <member name="T:CqCore.SerializeType">
            <summary>
            定义一个类型的序列化方式和名字
            </summary>
        </member>
        <member name="F:CqCore.SerializeType.type">
            <summary>
            可序列化的类型
            </summary>
        </member>
        <member name="F:CqCore.SerializeType.name">
            <summary>
            序列化识别名称
            </summary>
        </member>
        <member name="F:CqCore.SerializeType.style">
            <summary>
            对这个类型序列化方式
            </summary>
        </member>
        <member name="T:CqCore.ParserFormat">
            <summary>
            序列化样式
            </summary>
        </member>
        <member name="P:CqCore.ParserFormat.ExpSeparator">
            <summary>
            表达式分隔符
            </summary>
        </member>
        <member name="P:CqCore.ParserFormat.ExpEnd">
            <summary>
            表达式结束符
            </summary>
        </member>
        <member name="P:CqCore.ParserFormat.ExpStart">
            <summary>
            表达式起始
            </summary>
        </member>
        <member name="M:CqCore.ParserFormat.#ctor(CqCore.SerializeFormatStyle)">
            <summary>
            解析序列化内容样式
            </summary>
        </member>
        <member name="T:CqCore.SerializeFormat">
            <summary>
            序列化样式
            </summary>
        </member>
        <member name="F:CqCore.SerializeFormat.depthMax">
            <summary>
            序列化深度
            </summary>
        </member>
        <member name="F:CqCore.SerializeFormat.startWithType">
            <summary>
            序列化内容以类型起始(这样在反序列化时不用传递类型)
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.withHashId">
            <summary>
            当不确定序列化的对象内部成员一定没有相互引用时,开启这个变量,排除对同一对象的重复序列化
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.serializeObjByProperty">
            <summary>
            对普通对象的默认序列化方式
            true:属性
            false:字段
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.ExpSeparator">
            <summary>
            表达式分隔符
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.ExpEnd">
            <summary>
            表达式结束符
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.ExpStart">
            <summary>
            表达式起始
            </summary>
        </member>
        <member name="P:CqCore.SerializeFormat.Enter">
            <summary>
            回车符
            </summary>
        </member>
        <member name="F:CqCore.SerializeFormat.Tab">
            <summary>
            制表符
            </summary>
        </member>
        <member name="F:CqCore.SerializeFormat._GetTbls">
            <summary>
            获取多个制表符
            </summary>
        </member>
        <member name="M:CqCore.SerializeFormat.#ctor(CqCore.SerializeFormatStyle,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            序列化样式
            </summary>
            <param name="se_style">序列化格式</param>
            <param name="withOutFormatChar">不包含格式控制符(换行或者制表符等)</param>
            <param name="serializeObjByProperty">不包含格式控制符(换行或者制表符等)</param>
            <param name="withHashId">当不确定序列化的对象内部成员一定没有相互引用时,开启记录对象的id,保证同一对象不被重复序列化</param>
        </member>
        <member name="T:CqCore.FunctorComparer`1">
            <summary>
            内置比较器
            </summary>
        </member>
        <member name="T:CqCore.List_GC`1">
            <summary>
             动态数组(gc==0)<para/>
             科普ArrayList Lis&lt;T&gt; , T[] 区别<para/>
             1.ArrayList 不支持泛型 ,可动态扩容 ,统一按object存储 值类型存储会产生装箱<para/>
             2.Lis&lt;T&gt; 支持泛型 ,可动态扩容 ,部分操作有GC<para/>
             3. T[] 支持泛型 ,不可动态扩容
            </summary>
        </member>
        <member name="M:CqCore.List_GC`1.Add(`0)">
            <summary>
            增加单元
            </summary>
            <param name="element">添加的单元</param>
        </member>
        <member name="M:CqCore.List_GC`1.Insert(System.Int32,`0)">
            <summary>
            插入单元
            </summary>
            <param name="index">插入位置</param>
            <param name="element">单元</param>
            <returns>操作是否成功</returns>
        </member>
        <member name="M:CqCore.List_GC`1.increaseCapacity">
            <summary>
            增长容量
            </summary>
        </member>
        <member name="M:CqCore.List_GC`1.Clear">
            <summary>
            清空单元数组
            </summary>
        </member>
        <member name="M:CqCore.List_GC`1.Contains(`0)">
            <summary>
            是否包含某个单元
            </summary>
            <param name="element">单元</param>
            <returns>是否包含</returns>
        </member>
        <member name="M:CqCore.List_GC`1.IndexOf(`0)">
            <summary>
            获取指定单元在当前列表中的位置，从前向后查找
            </summary>
            <param name="element">单元</param>
            <returns>位置</returns>
        </member>
        <member name="M:CqCore.List_GC`1.LastIndexOf(`0)">
            <summary>
            获取指定单元在当前列表中的位置，从后先前查找
            </summary>
            <param name="element">单元</param>
            <returns>位置</returns>
        </member>
        <member name="P:CqCore.List_GC`1.Count">
            <summary>
            获得长度
            </summary>
        </member>
        <member name="M:CqCore.List_GC`1.RemoveAt(System.Int32)">
            <summary>
            移除指定位置的单元，如果单元归属权属于当前列表，则会将其卸载
            </summary>
            <param name="index">位置索引</param>
            <returns>移除掉的单元</returns>
        </member>
        <member name="M:CqCore.List_GC`1.RemoveEnd">
            <summary>
            移除指定尾部单元
            </summary>
            <returns>移除掉的单元</returns>
        </member>
        <member name="M:CqCore.List_GC`1.RemoveAllFrom(System.Int32)">
            <summary>
            从指定位置开始(包括当前)，移除后续单元，如果单元归属权属于当前列表，则会将其卸载
            </summary>
            <param name="index">要移除的位置</param>
            <returns>被移除的个数，如果index越界，则返回-1</returns>
        </member>
        <member name="M:CqCore.List_GC`1.Remove(`0)">
            <summary>
            移除指定单元，如果单元归属权属于当前列表，则会将其卸载
            </summary>
            <param name="element">单元</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:CqCore.List_GC`1.GetAllItems">
            <summary>
            获取所有数据，注意这里的数据可能包含了很多冗余空数据，长度>=当前数组长度。
            </summary>
            <returns>所有数据数组</returns>
        </member>
        <member name="M:CqCore.List_GC`1.ToArray">
            <summary>
            转换成定长数组，伴随着内容拷贝。
            如果是值类型数组，将与本动态数组失去关联；
            如果是引用类型数组，将与本动态数组保存相同的引用。
            </summary>
            <returns>数组</returns>
        </member>
        <member name="M:CqCore.List_GC`1.Print">
            <summary>
            显示此数组，每个单元之间以逗号分隔
            </summary>
        </member>
        <member name="M:CqCore.List_GC`1.PrintByLines">
            <summary>
            显示此数组，每个单元一行
            </summary>
        </member>
        <member name="T:CqCore.BufferPool">
            <summary>
            缓冲池
            在编写网络应用的时候数据缓冲区是应该比较常用的方式，
            主要用构建一个内存区用于存储发送的数据和接收的数据；
            为了更好的利用已有数据缓冲区所以构造一个缓冲池来存放相关数据方便不同连接更好地利用缓冲区，
            节省不停的构造新的缓冲区所带的损耗问题。
            </summary>
        </member>
        <member name="T:CqCore.CqCoroutine">
            <summary>
            支持嵌套的协程
            </summary>
        </member>
        <member name="P:CqCore.CqCoroutine.Updating">
            <summary>
            是否在线程中循环
            </summary>
        </member>
        <member name="M:CqCore.CqCoroutine.Start(CqCore.ICancelHandle,System.Action)">
            <summary>
            添加到主线程中循环执行<para/>
            已经在执行返回false
            </summary>
        </member>
        <member name="M:CqCore.CqCoroutine.Stop">
            <summary>
            终止这个协程
            </summary>
        </member>
        <member name="F:CqCore.CqCoroutine.stacktrace">
            <summary>
            执行协程时的堆栈
            </summary>
        </member>
        <member name="T:CqCore.CqRange">
            <summary>
            对应数轴上的一个区间(前后都是闭合的区间,可以看成一个线段)
            </summary>
        </member>
        <member name="M:CqCore.CqRange.op_Addition(CqCore.CqRange,CqCore.CqRange)">
            <summary>
            区间并集<para/>
            两区间不重叠也不相邻时返回null
            </summary>
        </member>
        <member name="M:CqCore.CqRange.op_Subtraction(CqCore.CqRange,CqCore.CqRange)">
            <summary>
            区间差集<para/>
            ab不重叠时返回null<para/>
            b完全覆盖a时返回长度为0的列表
            </summary>
        </member>
        <member name="M:CqCore.CqRange.op_Multiply(CqCore.CqRange,CqCore.CqRange)">
            <summary>
            区间交集
            </summary>
        </member>
        <member name="T:CqCore.DataBuffer">
            <summary>
            缓冲区
            </summary>
        </member>
        <member name="T:CqCore.ITreeDataNode`1">
            <summary>
            树形数据结构数据类,基类
            </summary>
        </member>
        <member name="P:CqCore.ITreeDataNode`1.Node">
            <summary>
            对应的树节点
            </summary>
        </member>
        <member name="T:CqCore.TreeNode`1">
            <summary>
            通用树形数据结构节点(参考Transform实现)
            </summary>
        </member>
        <member name="F:CqCore.TreeNode`1.mData">
            <summary>
            挂在这个节点上的数据
            </summary>
        </member>
        <member name="P:CqCore.TreeNode`1.Data">
            <summary>
            挂在这个节点上的数据
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.AddChildren(CqCore.TreeNode{`0})">
            <summary>
            添加一个叶子节点
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.Delete">
            <summary>
            删除这个节点
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.DeleteToParent">
            <summary>
            删除这个节点,并且删除后如果父节点没有孩子了,也要一并删除
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.LeafCount">
            <summary>
            返回树的叶子个数
            </summary>
        </member>
        <member name="P:CqCore.TreeNode`1.Layer">
            <summary>
            深度
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.IsLeaf">
            <summary>
            该节点是否是叶子
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.IsRoot">
            <summary>
            该节点是否是根节点
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.Degree">
            <summary>
            该节点的度,或者说子节点个数
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.Size">
            <summary>
            叶子节点和分支节点的总数
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.Height">
            <summary>
            返回树/节点的高度(深度)
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.PreorderTraversal(System.Action{CqCore.TreeNode{`0}})">
            <summary>
            先序遍历(深度优先遍历Depth-first Traversal的一种)
            </summary>
        </member>
        <member name="M:CqCore.TreeNode`1.FindByPreorder(System.Predicate{CqCore.TreeNode{`0}})">
            <summary>
            先序遍历查找
            返回true时找到目标
            终止遍历
            </summary>
        </member>
        <member name="T:CqCore.INotifyMemberChanged">
            <summary>
            继承于这个接口的类,可以派发成员变更事件<para/>
            外部系统可以监听成员变更
            </summary>
        </member>
        <member name="T:CqCore.INotifyListChanged">
            <summary>
            实现这个接口的类,可以派列表改变通知
            </summary>
        </member>
        <member name="T:CqCore.CqDebug">
            <summary>
            打印函数
            </summary>
        </member>
        <member name="F:CqCore.CqDebug.LogHandle">
            <summary>
            打印
            </summary>
        </member>
        <member name="M:CqCore.CqDebug.Log(System.Object,CqCore.LogType)">
            <summary>
            调用注入的打印函数来打印
            </summary>
        </member>
        <member name="M:CqCore.CqDebug.LogInCoroutine(System.Object,CqCore.LogType)">
            <summary>
            在协程中调用注入的打印函数来打印
            </summary>
        </member>
        <member name="M:CqCore.CqDebug.TestExec(System.Action,System.UInt32)">
            <summary>
            执行函数,打印执行时间
            </summary>
        </member>
        <member name="M:CqCore.CqDebug.ExecFun(System.Action,System.UInt32)">
            <summary>
             执行函数,返回执行时间(s)
            </summary>
        </member>
        <member name="F:CqCore.LogType.Error">
            <summary>
            错误
            </summary>
        </member>
        <member name="F:CqCore.LogType.Assert">
            <summary>
            断言
            </summary>
        </member>
        <member name="F:CqCore.LogType.Warning">
            <summary>
            警告
            </summary>
        </member>
        <member name="F:CqCore.LogType.Log">
            <summary>
            日志
            </summary>
        </member>
        <member name="F:CqCore.LogType.Exception">
            <summary>
            异常
            </summary>
        </member>
        <member name="T:CqCore.CqTweenBezier`1">
            <summary>
            贝塞尔插值缓动泛型类
            </summary>
        </member>
        <member name="M:CqCore.CqTweenBezier`1.OnFrame(System.Single)">
            <summary>
            在差值系数的改变中回调设置属性值.
            </summary>
        </member>
        <member name="T:CqCore.CqTweenBezier">
            <summary>
            贝塞尔插值缓动基类
            </summary>
        </member>
        <member name="T:CqCore.CqTweenLerp">
            <summary>
            线性插值缓动基类
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Linear">
            <summary>
            直线
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Quadratic">
            <summary>
            二次
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Cubic">
            <summary>
            三次
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Quartic">
            <summary>
            四次
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Quintic">
            <summary>
            五次
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Expo">
            <summary>
            指数
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Back">
            <summary>
            返回
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Sine">
            <summary>
            正弦
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Circle">
            <summary>
            圆弧
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Elastic">
            <summary>
            弹性振荡
            </summary>
        </member>
        <member name="F:CqCore.EaseFunEnum.Bounce">
            <summary>
            反弹
            </summary>
        </member>
        <member name="F:CqCore.EaseStyleEnum.EaseIn">
            <summary>
            缓入(渐快)
            </summary>
        </member>
        <member name="F:CqCore.EaseStyleEnum.EaseOut">
            <summary>
            缓出(渐慢)
            </summary>
        </member>
        <member name="F:CqCore.EaseStyleEnum.EaseInOut">
            <summary>
            缓入缓出
            </summary>
        </member>
        <member name="T:CqCore.CqEventAttribute">
            <summary>
            事件打印
            </summary>
        </member>
        <member name="T:CqCore.CustomEventArgs">
            <summary>
            事件消息体抽象类
            </summary>
        </member>
        <member name="M:CqCore.CustomEventArgs.Notify(System.Object)">
            <summary>
            分发事件
            </summary>
        </member>
        <member name="T:CqCore.ComparisonPriority`1">
            <summary>
            对象优先级计算函数
            </summary>
        </member>
        <member name="T:CqCore.ComparisonFloatPriority`1">
            <summary>
            对象优先级计算函数
            </summary>
        </member>
        <member name="T:CqCore.NetState">
            <summary>
            网络连接状态
            </summary>
        </member>
        <member name="F:CqCore.TweenHandleBase.OnComplete">
            <summary>
            缓动完成后回调
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.OnFrame(System.Single)">
            <summary>
            缓动时回调0~1
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.Cancel">
            <summary>
            终止缓动
            </summary>
        </member>
        <member name="P:CqCore.TweenHandleBase.IsTweening">
            <summary>
            是否正在缓动
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.Play(System.Single,CqCore.ICancelHandle,System.Single,System.Single)">
            <summary>
            播放缓动<para/>
            由播放者来管理终止操作
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.Play_IT(System.Single,System.Single,System.Single)">
            <summary>
            接入外部协程,完成一系列缓动
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.PlayTo_IT(System.Single,System.Single)">
            <summary>
            接入外部协程,完成一系列缓动
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.Immediately">
            <summary>
            立即完成
            </summary>
        </member>
        <member name="M:CqCore.TweenHandleBase.CoreTween(System.Action{System.Single},System.Single,System.Single,System.Single)">
            <summary>
            缓动核心函数 
            OnFrame 每帧回调 ,值从startPercent~endPercent
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.GetProcessByLockFile(System.String,System.String)">
            <summary>
             查询占用文件的进程
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.GetCurrentProcessFileName">
            <summary>
            获取当前进程的完整路径
            </summary>
            <returns></returns>
        </member>
        <member name="M:CqCore.ProcessUtil.FindProcess(System.Predicate{System.Diagnostics.Process})">
            <summary>
            模糊查找进程
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.FindProcess(System.String)">
            <summary>
            模糊查找进程
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.Done(System.String,System.String)">
            <summary>
            打开软件并执行命令
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.OpenExplorer(System.String)">
            <summary>
            由系统根据相应的文件扩展名调用相应的执行程序打开文件.<para/>
            如果是一个链接,会调用默认浏览器来打开链接
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.KillProcess(System.String)">
            <summary>
            通过名称杀进程
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.KillProcessByOccupyFile(System.String)">
            <summary>
            通过名称杀进程
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.OpenFileOrFolderByExplorer(System.String)">
            <summary>
            系统调用文件或者文件夹的浏览窗口并选中路径
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.Start(System.String,System.String,System.Boolean)">
            <summary>
            执行程序,或者用系统的打开方式来打开文件
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.SVNUpdate(System.String)">
            <summary>
            SVN更新
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.SVNCheckout(System.String,System.String)">
            <summary>
            SVN检出
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.SVNCommit(System.Collections.Generic.List{System.String})">
            <summary>
            SVN提交
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.SVNCommand(System.String,System.Boolean)">
            <summary>
            SVN命令
            </summary>
            <param name="command"></param>
            <param name="autoClose">如果没发生错误和冲突则自动关闭对话框</param>
            <returns></returns>
        </member>
        <member name="M:CqCore.ProcessUtil.DoneCmd(System.String)">
            <summary>
            命令行
            </summary>
        </member>
        <member name="M:CqCore.ProcessUtil.KillExcelProcess">
            <summary>
            杀excel进程
            </summary>
        </member>
        <member name="M:CqCore.EnvironmentUtil.GetCommandLineArgs">
            <summary>
            获取应用程序启动参数
            </summary>
            <returns></returns>
        </member>
        <member name="M:CqCore.CqTweenCore.BaseTween``1(System.Action{System.Object},``0,``0,System.Single,System.Func{System.Single,System.Single},System.Func{``0,``0,System.Single,``0},System.Action,System.Single)">
            <summary>
            基础缓动函数
            </summary>
        </member>
        <member name="M:CqCore.CqTweenCore.BaseFrame(System.Action{System.Single},System.Single,System.Action,System.Single)">
            <summary>
            基础缓动函数
            time 0~1变化的总时间
            </summary>
        </member>
        <member name="M:CqCore.CqTweenCore.CoreTween(System.Action{System.Single},System.Single,System.Single)">
            <summary>
            缓动核心函数 
            OnFrame 每帧回调 ,值从0~1
            GetDeltaTime 每帧的时间差
            </summary>
        </member>
        <member name="T:CqCore.CqTweenLerp`1">
            <summary>
            线性插值缓动泛型类
            </summary>
        </member>
        <member name="M:CqCore.CqTweenLerp`1.OnFrame(System.Single)">
            <summary>
            在差值系数的改变中回调设置属性值.
            </summary>
        </member>
        <member name="M:CqCore.ColorUtil.ColorHtmlToBytes(System.String)">
            <summary>
            ARGB格式字符串转Color
            </summary>
        </member>
        <member name="M:CqCore.ColorUtil.ARGBHtmlToRGBA(System.String)">
            <summary>
            #F000FF00=>00FF00F0
            </summary>
        </member>
        <member name="P:CqCore.CqRandom.Seed">
            <summary>
            随机种子
            </summary>
        </member>
        <member name="M:CqCore.CqRandom.Next">
            <summary>
            返回x(0&lt;=x&lt;int.MaxValue)
            </summary>
        </member>
        <member name="M:CqCore.CqRandom.Next(System.Int32)">
            <summary>
            返回x(0&lt;=x&lt;maxValue)
            </summary>
        </member>
        <member name="M:CqCore.CqRandom.Next(System.Int32,System.Int32)">
            <summary>
            返回大于等于minValue,小于maxValue的整数
            </summary>
        </member>
        <member name="M:CqCore.CqRandom.NextDouble">
            <summary>
            返回0~1之间的浮点数
            </summary>
        </member>
        <member name="T:CqCore.Matrix">
            <summary>
            矩阵
            </summary>
        </member>
        <member name="M:CqCore.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            矩阵
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_Equality(CqCore.Matrix,CqCore.Matrix)">
            <summary>
            //判断矩阵相等
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_Inequality(CqCore.Matrix,CqCore.Matrix)">
            <summary>
            //判断矩阵不等
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_Addition(CqCore.Matrix,CqCore.Matrix)">
            <summary>
            矩阵相加
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_Subtraction(CqCore.Matrix,CqCore.Matrix)">
            <summary>
            矩阵相减
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_Multiply(CqCore.Matrix,System.Double)">
            <summary>
            矩阵与常数相乘
            </summary>
        </member>
        <member name="M:CqCore.Matrix.op_BitwiseOr(CqCore.Matrix,CqCore.Matrix)">
            <summary>
            两矩阵形成的增广矩阵
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Transpose">
            <summary>
            转置
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Adjoint">
            <summary>
            伴随矩阵
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Rank">
             <summary>
             计算矩阵的秩
             计算矩阵的秩，即把矩阵进行行初等变换，得出的行最简矩阵的非零行数。过程如下
            1）将矩阵各行按第一个非零元素出现的位置升序排列（Operation1函数）
            2）查看矩阵是否为行最简矩阵（isFinished函数），是则到第6步，不是则到第3步
            3）如果有两行第一个非零元素出现的位置相同，则做消法变换，让下面行的第一个非零元素位置后移（Operation2函数）
            4）将矩阵各行按第一个非零元素出现的位置升序排列（Operation1函数）
            5）返回第2步
            6）判断误差，对趋近与0的元素（如1E-5）按0处理，以免在第7步误判（Operation3函数）
            7）统计非零行的数目（Operation4函数），即为矩阵的秩
             </summary>
        </member>
        <member name="M:CqCore.Matrix.CalcMatrix(CqCore.Matrix,CqCore.Matrix,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            a,b 做代数计算
            </summary>
        </member>
        <member name="M:CqCore.Matrix.isFinished">
            <summary>
            判断矩阵是否变换到最简形式（非零行数达到最少）
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Operation1">
            <summary>
            排序（按左侧最前非零位位置自上而下升序排列）
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Operation2">
            <summary>
            行初等变换（左侧最前非零位位置最靠前的行，只保留一个）
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Operation3">
            <summary>
            将和0非常接近的数字视为0
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Operation4">
            <summary>
            计算行最简矩阵的秩
            </summary>
        </member>
        <member name="M:CqCore.Matrix.Swap(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            交换两个元素
            </summary>
        </member>
        <member name="T:CqCore.MathUtil">
             <summary>
            常用算法类
             </summary>
             <summary>
            常用算法类
             </summary>
             <summary>
            常用算法类
             </summary>
             <summary>
            常用算法类
             </summary>
             <summary>
            常用算法类
             </summary>
        </member>
        <member name="M:CqCore.MathUtil.Comparison(System.Type)">
            <summary>
            得到一个通用排序的函数
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.LerpT(System.Single,System.Single,System.Single)">
            <summary>
            求插值系数
            (b-a)/(c-a)
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.LerpT(System.Object,System.Object,System.Object)">
            <summary>
            求插值系数
            (b-a)/(c-a)
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.LineLerpUnclamped(System.Object,System.Object,System.Double)">
            <summary>
            一次插值公式 a*(1-t)+b*t (一次贝塞尔)
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.LineLerp(System.Double,System.Double,System.Double)">
            <summary>
            t小于0时为0 大于1时为1
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.LineLerp(System.Object,System.Object,System.Double)">
            <summary>
            t小于0时为0 大于1时为1
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateCheck(System.Int32,System.Int32)">
            <summary>
            状态判断
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateAdd(System.Int32,System.Int32)">
            <summary>
            返回状态相加的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateChange(System.Int32,System.Int32)">
            <summary>
            返回状态切换后的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateDel(System.Int32,System.Int32)">
            <summary>
            返回从n中删除bit的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateCheck``1(``0,``0)">
            <summary>
            状态判断
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateAdd``1(``0,``0)">
            <summary>
            返回状态相加的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateChange``1(``0,``0)">
            <summary>
            返回状态切换后的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.StateDel``1(``0,``0)">
            <summary>
            返回从n中删除bit的结果
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.KeepNumber(System.Double,System.Int32)">
            <summary>
            保留digits位有效数字(向下取整)
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.CalculateStdDev(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            标准差
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.Mod(System.Int32@,System.Int32)">
            <summary>
            整数除法 返回余数 原始数据改为商
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.InverseNumber(System.Single[])">
            <summary>
            数轴的逆序数
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.GetIndexOfExtent(System.Single,System.Single@,System.Collections.Generic.IList{System.Single})">
            <summary>
            数在数轴上的区间位置（从0开始） args从小到大排列<para/>
            t为该数在所在区间的插值系数<para/>
            每区间前闭后开<para/>
            比如:value=2.5,args={0,2,3,9} ,args把 数轴分成5个区间(-无穷大,0),[0,2),[2,3),[3,9),[9,+无穷大),而2.5在第3个区间上所以返回索引2,2.5在2~3之间的插值为t=0.5
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.BetweenRange(System.Single@,System.Single,System.Single)">
            <summary>
            确保value在start和end之间,
            如果value比start小,value=start,
            如果value比end大,value=end
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.BetweenRange(System.Int32@,System.Int32,System.Int32)">
            <summary>
            确保value在start和end之间,
            如果value比start小,value=start,
            如果value比end大,value=end
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.MoveToRange(System.Single,System.Single,System.Single)">
            <summary>
            将数据按区间的范围为单位,移动到区间内,一般用于角度计算(start,end)
            例:MoveToRange( -60,0,360) 结果为300 
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.MoveToRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            将数据按区间的范围为单位,移动到区间内,一般用于角度计算(start,end)
            例:MoveToRange( -60,0,360) 结果为300 
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.InMassileRange(System.Single,System.Single)">
             <summary>
            是否在弹道距离内 
             </summary>
        </member>
        <member name="M:CqCore.MathUtil.CompareCopy``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            (高效copy)非清空的方式（添加没有的，删除多余的），将一个表赋值给另一个表
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.DegreeToRadianConvert(System.Double)">
            <summary>
            角度转弧度
            </summary>
        </member>
        <member name="M:CqCore.MathUtil.OneVariableQuadraticExpr(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            由3个点推导一元二次函数
            </summary>
        </member>
        <member name="M:CqCore.NetUtil.ConnectTest(System.String,System.Int32)">
            <summary>
            PING测试
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.LocalIP">
            <summary>
            返回启用的网卡中的一个本地IP
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.HostIPList">
            <summary>
            返回IP列表
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.Host">
            <summary>
            返回主机
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.HostName">
            <summary>
            返回主机名
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.MachineName">
            <summary>
            获取此本地计算机的 NetBIOS 名称.
            </summary>
        </member>
        <member name="P:CqCore.NetUtil.VersionString">
            <summary>
            获取平台标识符,版本和当前安装在操作系统上的Service Pack
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.Random(System.Single,System.Single)">
            <summary>
            返回min,max之间的浮点数
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.Random(System.Int32,System.Int32)">
            <summary>
            返回大于等于min,小于max的整数
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.RandomIt(System.Collections.IList)">
            <summary>
            随机获取一个列表元素
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.RandomIt_T``1(System.Collections.Generic.IList{``0})">
            <summary>
            随机获取一个列表元素
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.RandomShuffle(System.Collections.IList)">
            <summary>
            乱序数组
            </summary>
        </member>
        <member name="M:CqCore.RandomUtil.GetIndexs(System.Collections.Generic.IList{System.Single},System.Int32,System.Boolean)">
            <summary>
            从若干个元素中,随机取出n个元素组成列表<para/>
            </summary>
            <param name="weightList">每个元素对应的权重组成的列表</param>
            <param name="num">随机抽取数量</param>
            <param name="repeat">是否可以重复抽取</param>
            <returns>返回随机到的元素在权重列表对应的索引</returns>
        </member>
        <member name="M:CqCore.RegexUtil.IsMatch(System.String,System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>  
            验证字符串是否匹配正则表达式描述的规则  
            </summary>  
            <param name="inputStr">待验证的字符串</param>  
            <param name="patternStr">正则表达式字符串</param>  
            <param name="startat">开始搜索的字符位置</param>  
            <param name="ifIgnoreCase">匹配时是否不区分大小写</param>  
            <param name="ifValidateWhiteSpace">是否验证空白字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:CqCore.RegexUtil.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            在指定的输入字符串中搜索 pattern 参数中提供的正则表达式的匹配项。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.Match(System.String,System.String,System.Int32)">
            <summary>
            在指定的输入字符串中搜索 pattern 参数中提供的正则表达式的匹配项。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            在指定的输入字符串中搜索 pattern 参数中指定的正则表达式的所有匹配项。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            在指定的输入字符串中搜索 pattern 参数中指定的正则表达式的所有匹配项。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.Replace(System.String,System.String,System.String,System.Int32)">
            <summary>
            在指定输入字符串内，使用指定替换字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            在指定的输入字符串内，使用 System.Text.RegularExpressions.MatchEvaluator 委托返回的字符串替换与指定正则表达式匹配的所有字符串。指定的选项将修改匹配操作。
            </summary>
        </member>
        <member name="M:CqCore.RegexUtil.MatchReplace(System.String,System.String,System.Func{System.Int32,System.Text.RegularExpressions.Match,System.String})">
            <summary>
            查找pattern捕获替换为函数OnMatch调用的返回值
            </summary>
        </member>
        <member name="M:CqCore.Util.CharAryToString(System.Char[],System.UInt32,System.UInt32)">
            <summary>
            以字符数组中的回车符分隔成字符串数组
            </summary>
        </member>
        <member name="T:Business.Command">
            <summary>
            Command 的摘要说明。
            </summary>
        </member>
        <member name="M:Business.Command.LinkIntoFolder(System.String,System.String)">
            <summary>
            将 srcFolder 文件夹链接到 dstFolder 下
            </summary>
        </member>
        <member name="M:Business.Command.LinkFolder(System.String,System.String)">
            <summary>
            如果dstFolder文件夹存在,会被删除.
            将 srcFolder 文件夹链接到 dstFolder
            </summary>
        </member>
        <member name="M:Business.Command.CopyFolder(System.String,System.String)">
            <summary>
            文件夹拷贝
            </summary>
        </member>
        <member name="M:Business.Command.RunCmd(System.String)">
            <summary>
            执行CMD语句
            </summary>
            <param name="cmd">要执行的CMD命令</param>
        </member>
        <member name="T:ConsoleManager">
            <summary>
            非控制台应用程序的弹出控制台用法
            ConsoleManager.Show();
            ConsoleManager.HasConsole
            </summary>
        </member>
        <member name="M:ConsoleManager.Show">
            Creates a new console instance if the process is not attached to a console already.  
        </member>
        <member name="M:ConsoleManager.Hide">
            If the process has a console attached to it, it will be detached and no longer visible. Writing to the System.Console is still possible, but no output will be shown.   
        </member>
        <member name="T:IConfig">
            <summary>
            配置数据结构接口类
            </summary>
        </member>
        <member name="T:CalcOperator">
            <summary>
            计算运算符
            </summary>
        </member>
        <member name="T:ConditionOperator">
            <summary>
            条件运算符
            </summary>
        </member>
        <member name="T:WatcherFileChangeAttribute">
            <summary>
            修饰一个文件名,当文件改变时发出通知
            </summary>
        </member>
        <member name="M:WatcherFileChangeAttribute.#ctor(System.String)">
            <summary>
            修饰一个文件名,当文件改变时发出通知
            </summary>
            <param name="changeFunName">文件改变时通知的外部函数名</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksum.Adler32">
            <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Checksum.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksum.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Adler32.#ctor">
            <summary>
            Creates a new instance of the Adler32 class.
            The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with a byte value.
            </summary>
            <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with an array of bytes.
            </summary>
            <param name="buffer">
            The source of the data to update with.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            an array of bytes
            </param>
            <param name="offset">
            the start of the data used for this update
            </param>
            <param name="count">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc">
             <summary>
             CRC-32 with unreversed data and reversed output
             </summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.checkValue">
            <summary>
            The CRC data checksum so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc"></see>
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.Reset">
            <summary>
            Resets the CRC data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.Value">
            <summary>
            Returns the CRC data checksum computed so far.
            </summary>
            <remarks>Reversed Out = true</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "bval">
            the byte is taken as the lower 8 bits of bval
            </param>
            <remarks>Reversed Data = false</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.Update(System.Byte[])">
            <summary>
            Updates the CRC data checksum with the bytes taken from
            a block of data.
            </summary>
            <param name="buffer">Contains the data to update the CRC with.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.BZip2Crc.Update(System.ArraySegment{System.Byte})">
            <summary>
            Update CRC data checksum based on a portion of a block of data
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksum.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Checksum.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksum.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.Crc32.Update(System.ArraySegment{System.Byte})">
            <summary>
            Update CRC data checksum based on a portion of a block of data
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksum.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "value">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksum.IChecksum.Update(System.ArraySegment{System.Byte})">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "segment">
            The chunk of data to add
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs">
            <summary>
            Event arguments for scanning.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.Name">
            <summary>
            The fie or directory name for this event.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating if scanning should continue or not.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs">
            <summary>
            Event arguments during processing of a single file or directory.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name if known.</param>
            <param name="processed">The number of bytes processed so far</param>
            <param name="target">The total number of bytes to process, 0 if not known</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Name">
            <summary>
            The name for this event if known.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating wether scanning should continue or not.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.PercentComplete">
            <summary>
            Get a percentage representing how much of the <see cref="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Target"></see> has been processed
            </summary>
            <value>0.0 to 100.0 percent; 0 if target is not known.</value>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Processed">
            <summary>
            The number of bytes processed so far
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Target">
            <summary>
            The number of bytes to process.
            </summary>
            <remarks>Target may be 0 or negative if the value isnt known.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs">
            <summary>
            Event arguments for directories.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize an instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs"></see>.
            </summary>
            <param name="name">The name for this directory.</param>
            <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs.HasMatchingFiles">
            <summary>
            Get a value indicating if the directory contains any matching files or not.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs">
            <summary>
            Arguments passed when scan failures are detected.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs"></see>
            </summary>
            <param name="name">The name to apply.</param>
            <param name="e">The exception to use.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.Name">
            <summary>
            The applicable name.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.Exception">
            <summary>
            The applicable exception.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.ContinueRunning">
            <summary>
            Get / set a value indicating wether scanning should continue.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProcessDirectoryHandler">
            <summary>
            Delegate invoked before starting to process a directory.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProcessFileHandler">
            <summary>
            Delegate invoked before starting to process a file.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProgressHandler">
            <summary>
            Delegate invoked during processing of a file or directory
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.CompletedFileHandler">
            <summary>
            Delegate invoked when a file has been completely processed.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.DirectoryFailureHandler">
            <summary>
            Delegate invoked when a directory failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.FileFailureHandler">
            <summary>
            Delegate invoked when a file failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner">
            <summary>
            FileSystemScanner provides facilities scanning of files and directories.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="filter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply when scanning.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(System.String,System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter"> directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(ICCEmbedded.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(ICCEmbedded.SharpZipLib.Core.IScanFilter,ICCEmbedded.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
            <param name="directoryFilter">The directory <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.ProcessDirectory">
            <summary>
            Delegate to invoke when a directory is processed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.ProcessFile">
            <summary>
            Delegate to invoke when a file is processed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.CompletedFile">
            <summary>
            Delegate to invoke when processing for a file has finished.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.DirectoryFailure">
            <summary>
            Delegate to invoke when a directory failure is detected.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.FileFailure">
            <summary>
            Delegate to invoke when a file failure is detected.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnDirectoryFailure(System.String,System.Exception)">
            <summary>
            Raise the DirectoryFailure event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnFileFailure(System.String,System.Exception)">
            <summary>
            Raise the FileFailure event.
            </summary>
            <param name="file">The file name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnProcessFile(System.String)">
            <summary>
            Raise the ProcessFile event.
            </summary>
            <param name="file">The file name.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnCompleteFile(System.String)">
            <summary>
            Raise the complete file event
            </summary>
            <param name="file">The file name</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnProcessDirectory(System.String,System.Boolean)">
            <summary>
            Raise the ProcessDirectory event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="hasMatchingFiles">Flag indicating if the directory has matching files.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.Scan(System.String,System.Boolean)">
            <summary>
            Scan a directory.
            </summary>
            <param name="directory">The base directory to scan.</param>
            <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.fileFilter_">
            <summary>
            The file filter currently in use.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.directoryFilter_">
            <summary>
            The directory filter currently in use.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.alive_">
            <summary>
            Flag indicating if scanning should continue running.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.INameTransform">
            <summary>
            INameTransform defines how file system names are transformed for use with archives.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.INameTransform.TransformFile(System.String)">
            <summary>
            Given a file name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed file name.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.INameTransform.TransformDirectory(System.String)">
            <summary>
            Given a directory name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed directory name</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">
            <summary>
            Scanning filters support filtering of names.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.IScanFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it 'matches' the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>Returns true if the name matches the filter, false if it does not match.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.NameFilter">
            <summary>
            NameFilter is a string matching class which allows for both positive and negative
            matching.
            A filter is a sequence of independant <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see> separated by semi-colons ';'
            Each expression can be prefixed by a plus '+' sign or a minus '-' sign to denote the expression
            is intended to include or exclude names.  If neither a plus or minus sign is found include is the default
            A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
            and not matching an exclude spec are deemed to match the filter.
            An empty filter matches any name.
            </summary>
            <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
            "+\.dat$;-^dummy\.dat$"
            </example>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.#ctor(System.String)">
            <summary>
            Construct an instance based on the filter expression passed
            </summary>
            <param name="filter">The filter expression.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsValidExpression(System.String)">
            <summary>
            Test a string to see if it is a valid regular expression.
            </summary>
            <param name="expression">The expression to test.</param>
            <returns>True if expression is a valid <see cref="T:System.Text.RegularExpressions.Regex"/> false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsValidFilterExpression(System.String)">
            <summary>
            Test an expression to see if it is valid as a filter.
            </summary>
            <param name="toTest">The filter expression to test.</param>
            <returns>True if the expression is valid, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.ToString">
            <summary>
            Convert this filter to its string equivalent.
            </summary>
            <returns>The string equivalent for this filter.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsIncluded(System.String)">
            <summary>
            Test a value to see if it is included by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is included, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsExcluded(System.String)">
            <summary>
            Test a value to see if it is excluded by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is excluded, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsMatch(System.String)">
            <summary>
            Test a value to see if it matches the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value matches, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.Compile">
            <summary>
            Compile this filter.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.PathFilter">
            <summary>
            PathFilter filters directories and files using a form of <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see>
            by full path name.
            See <see cref="T:ICCEmbedded.SharpZipLib.Core.NameFilter">NameFilter</see> for more detail on filtering.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.PathFilter.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter"></see>.
            </summary>
            <param name="filter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.NameFilter">filter</see> expression to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.PathFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it matches the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>True if the name matches, false otherwise.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.StreamUtils">
            <summary>
            Provides simple <see cref="T:System.IO.Stream"/>" utilities.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/> ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="buffer">The buffer to fill.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/>" ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to store data in.</param>
            <param name="offset">The offset at which to begin storing data.</param>
            <param name="count">The number of bytes of data to store.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICCEmbedded.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String)">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
            <param name="progressHandler">The <see cref="T:ICCEmbedded.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
            <param name="updateInterval">The minimum <see cref="T:System.TimeSpan"/> between progress updates.</param>
            <param name="sender">The source for this event.</param>
            <param name="name">The name to use with the event.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.#ctor">
            <summary>
            Initialise an instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.StreamUtils"></see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassic">
            <summary>
            PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
            While it has been superceded by more recent and more powerful algorithms, its still in use and 
            is viable for preventing casual snooping
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
            <summary>
            Generates new encryption keys based on given seed
            </summary>
            <param name="seed">The seed value to initialise keys with.</param>
            <returns>A new key value.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase">
            <summary>
            PkzipClassicCryptoBase provides the low level facilities for encryption
            and decryption using the PkzipClassic algorithm.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.TransformByte">
            <summary>
            Transform a single byte 
            </summary>
            <returns>
            The transformed value
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.SetKeys(System.Byte[])">
            <summary>
            Set the key schedule for encryption/decryption.
            </summary>
            <param name="keyData">The data use to set the keys from.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys 
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.Reset">
            <summary>
            Reset the internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for encryption.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform"></see>
            </summary>
            <param name="keyBlock">The key block to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for decryption.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform"></see>.
            </summary>
            <param name="keyBlock">The key block to decrypt with.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged">
            <summary>
            Defines a wrapper object to access the Pkzip algorithm. 
            This class cannot be inherited.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
            <summary>
            Get / set the applicable block size in bits.
            </summary>
            <remarks>The only valid block size is 8.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">key sizes.</see>
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
            <summary>
            Generate an initial vector.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">block sizes</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.Key">
            <summary>
            Get / set the key value applicable.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
            <summary>
            Generate a new random key.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Create an encryptor.
            </summary>
            <param name="rgbKey">The key to use for this encryptor.</param>
            <param name="rgbIV">Initialisation vector for the new encryptor.</param>
            <returns>Returns a new PkzipClassic encryptor</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Create a decryptor.
            </summary>
            <param name="rgbKey">Keys to use for this new decryptor.</param>
            <param name="rgbIV">Initialisation vector for the new decryptor.</param>
            <returns>Returns a new decryptor.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.GZip.GZip">
            <summary>
            An example class to demonstrate compression and decompression of GZip streams.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZip.Decompress(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
            Decompress the <paramref name="inStream">input</paramref> writing
            uncompressed data to the <paramref name="outStream">output stream</paramref>
            </summary>
            <param name="inStream">The readable stream containing data to decompress.</param>
            <param name="outStream">The output stream to receive the decompressed data.</param>
            <param name="isStreamOwner">Both streams are closed on completion if true.</param>
            <exception cref="T:System.ArgumentNullException">Input or output stream is null</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZip.Compress(System.IO.Stream,System.IO.Stream,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Compress the <paramref name="inStream">input stream</paramref> sending
            result data to <paramref name="outStream">output stream</paramref>
            </summary>
            <param name="inStream">The readable stream to compress.</param>
            <param name="outStream">The output stream to receive the compressed data.</param>
            <param name="isStreamOwner">Both streams are closed on completion if true.</param>
            <param name="bufferSize">Deflate buffer size, minimum 512</param>
            <param name="level">Deflate compression level, 0-9</param>
            <exception cref="T:System.ArgumentNullException">Input or output stream is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Buffer Size is smaller than 512</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Compression level outside 0-9</exception>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.GZip.GZipConstants">
            <summary>
            This class contains constants used for gzip.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.GZIP_MAGIC">
            <summary>
            Magic number found at start of GZIP header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.FTEXT">
            <summary>
            Flag bit mask for text
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.FHCRC">
            <summary>
            Flag bitmask for Crc
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.FEXTRA">
            <summary>
            Flag bit mask for extra
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.FNAME">
            <summary>
            flag bitmask for name
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipConstants.FCOMMENT">
            <summary>
            flag bit mask indicating comment is present
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipConstants.#ctor">
            <summary>
            Initialise default instance.
            </summary>
            <remarks>Constructor is private to prevent instances being created.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.GZip.GZipException">
            <summary>
            GZipException represents exceptions specific to GZip classes and code.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipException.#ctor">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.GZip.GZipException" />.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipException.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.GZip.GZipException" /> with its message string.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.GZip.GZipException" />.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this exception.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.GZip.GZipInputStream">
             <summary>
             This filter stream is used to decompress a "GZIP" format stream.
             The "GZIP" format is described baseInputStream RFC 1952.
            
             author of the original java version : John Leuner
             </summary>
             <example> This sample shows how to unzip a gzipped file
             <code>
             using System;
             using System.IO;
            
             using ICSharpCode.SharpZipLib.Core;
             using ICSharpCode.SharpZipLib.GZip;
            
             class MainClass
             {
             	public static void Main(string[] args)
             	{
            			using (Stream inStream = new GZipInputStream(File.OpenRead(args[0])))
            			using (FileStream outStream = File.Create(Path.GetFileNameWithoutExtension(args[0]))) {
            				byte[] buffer = new byte[4096];
            				StreamUtils.Copy(inStream, outStream, buffer);
             		}
             	}
             }
             </code>
             </example>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.readGZIPHeader">
            <summary>
            Flag to indicate if we've read the GZIP header yet for the current member (block of compressed data).
            This is tracked per-block as the file is parsed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.completedLastBlock">
            <summary>
            Flag to indicate if at least one block in a stream with concatenated blocks was read successfully.
            This allows us to exit gracefully if downstream data is not in gzip format.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GZipInputStream with the default buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZIPInputStream with the specified buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads uncompressed data into an array of bytes
            </summary>
            <param name="buffer">
            The buffer to read uncompressed data into
            </param>
            <param name="offset">
            The offset indicating where the data should be placed
            </param>
            <param name="count">
            The number of uncompressed bytes to be read
            </param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream">
             <summary>
             This filter stream is used to compress a stream into a "GZIP" stream.
             The "GZIP" format is described in RFC 1952.
            
             author of the original java version : John Leuner
             </summary>
             <example> This sample shows how to gzip a file
             <code>
             using System;
             using System.IO;
            
             using ICSharpCode.SharpZipLib.GZip;
             using ICSharpCode.SharpZipLib.Core;
            
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             			using (Stream s = new GZipOutputStream(File.Create(args[0] + ".gz")))
             			using (FileStream fs = File.OpenRead(args[0])) {
             				byte[] writeData = new byte[4096];
             				Streamutils.Copy(s, fs, writeData);
             			}
             		}
             	}
             }
             </code>
             </example>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GzipOutputStream with the default buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZipOutputStream with the specified buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.SetLevel(System.Int32)">
            <summary>
            Sets the active compression level (0-9).  The new level will be activated
            immediately.
            </summary>
            <param name="level">The compression level to set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.GetLevel">
            <summary>
            Get the current compression level.
            </summary>
            <returns>The current compression level.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write given buffer to output updating crc
            </summary>
            <param name="buffer">Buffer to write</param>
            <param name="offset">Offset of first byte in buf to write</param>
            <param name="count">Number of bytes to write</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.Dispose(System.Boolean)">
            <summary>
            Writes remaining compressed output data to the output stream
            and closes it.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.GZip.GZipOutputStream.Finish">
            <summary>
            Finish compression and write any footer information required to stream
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>		
            <returns>Return true if input is needed via <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see>
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the 
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch"></param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.  
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.prev">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way 
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that 
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman">
            <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of Deflate and SetInput.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that all frequencies are zero
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            At least one frequency is non-zero
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>		
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending">
            <summary>
            This class stores the pending output of the Deflater.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream. 
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or 
            footer.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
            <summary>
            Creates a new inflater.
            </summary>
            <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.buffer_">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke 
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size to use when deflating
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close"></see> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.
            </summary>
            <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given password
            </summary>
            <param name="password">The password.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to read into.</param>
            <param name="offset">The offset to start storing data at.</param>
            <param name="count">The number of bytes to read</param>
            <param name="callback">The async callback to use.</param>
            <param name="state">The state to use.</param>
            <returns>Returns an <see cref="T:System.IAsyncResult"/></returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="offset">The offset to begin writing at.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> to use.</param>
            <param name="state">The state object.</param>
            <returns>Returns an IAsyncResult.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
            <summary>
            Calls <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buffer_">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICCEmbedded.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the [see] cref="ICCEmbedded.SharpZipLib.GZip.GZipInputStream"GZipInputStream [/see].
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close"/> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Number of bytes to skip is less than zero
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
            <param name="buffer">The buffer to write data from</param>
            <param name="offset">Offset of first byte to write</param>
            <param name="count">The maximum number of bytes to write</param>
            <param name="callback">The method to be called when the asynchronous write operation is completed</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
            <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
            <summary>
            Closes the input stream.  When <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isStreamOwner">
            <summary>
            Flag indicating wether this instance is designated the stream owner.
            When closing if this flag is true the underlying stream is closed.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZipEvents">
            <summary>
            FastZipEvents supports all events applicable to <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip">FastZip</see> operations.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">
            <summary>
            Delegate to invoke when processing directories.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessFile">
            <summary>
            Delegate to invoke when processing files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress">
            <summary>
            Delegate to invoke during processing of files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.CompletedFile">
            <summary>
            Delegate to invoke when processing for a file has been completed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">
            <summary>
            Delegate to invoke when processing directory failures.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.FileFailure">
            <summary>
            Delegate to invoke when processing file failures.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnDirectoryFailure(System.String,System.Exception)">
            <summary>
            Raise the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">directory failure</see> event.
            </summary>
            <param name="directory">The directory causing the failure.</param>
            <param name="e">The exception for this event.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnFileFailure(System.String,System.Exception)">
            <summary>
            Raises the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.FileFailure">file failure delegate</see>.
            </summary>
            <param name="file">The file causing the failure.</param>
            <param name="e">The exception for this failure.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnProcessFile(System.String)">
            <summary>
            Fires the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessFile">Process File delegate</see>.
            </summary>
            <param name="file">The file being processed.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnCompletedFile(System.String)">
            <summary>
            Fires the CompletedFile delegate
            </summary>
            <param name="file">The file whose processing has been completed.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnProcessDirectory(System.String,System.Boolean)">
            <summary>
            Fires the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">process directory</see> delegate.
            </summary>
            <param name="directory">The directory being processed.</param>
            <param name="hasMatchingFiles">Flag indicating if the directory has matching files as determined by the current filter.</param>
            <returns>A <see cref="T:System.Boolean"/> of true if the operation should continue; false otherwise.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProgressInterval">
            <summary>
            The minimum timespan between <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/> events.
            </summary>
            <value>The minimum period of time between <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/> events.</value>
            <seealso cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip">
            <summary>
            FastZip provides facilities for creating and extracting zip files.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite">
            <summary>
            Defines the desired handling when overwriting files during extraction.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Prompt">
            <summary>
            Prompt the user to confirm overwriting
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Never">
            <summary>
            Never overwrite files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Always">
            <summary>
            Always overwrite files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip"/>.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.#ctor(ICCEmbedded.SharpZipLib.Zip.FastZipEvents)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip"/>
            </summary>
            <param name="events">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZipEvents">events</see> to use during operations.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateEmptyDirectories">
            <summary>
            Get/set a value indicating wether empty directories should be created.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.Password">
            <summary>
            Get / set the password value.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.NameTransform">
            <summary>
            Get or set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"></see> active when creating Zip files.
            </summary>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.FastZip.EntryFactory"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.EntryFactory">
            <summary>
            Get or set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"></see> active when creating Zip files.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.RestoreDateTimeOnExtract">
            <summary>
            Get/set a value indicating wether file dates and times should 
            be restored when extracting files from an archive.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.RestoreAttributesOnExtract">
            <summary>
            Get/set a value indicating wether file attributes should
            be restored during extract operations
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate">
            <summary>
            Delegate called when confirming overwriting of files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Create a zip file.
            </summary>
            <param name="zipFileName">The name of the zip file to create.</param>
            <param name="sourceDirectory">The directory to source files from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create a zip file/archive.
            </summary>
            <param name="zipFileName">The name of the zip file to create.</param>
            <param name="sourceDirectory">The directory to obtain files and directories from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The file filter to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.IO.Stream,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Create a zip archive sending output to the <paramref name="outputStream"/> passed.
            </summary>
            <param name="outputStream">The stream to write archive data to.</param>
            <param name="sourceDirectory">The directory to source files from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,System.String)">
            <summary>
            Extract the contents of a zip file.
            </summary>
            <param name="zipFileName">The zip file to extract from.</param>
            <param name="targetDirectory">The directory to save extracted information in.</param>
            <param name="fileFilter">A filter to apply to files.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite,ICCEmbedded.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate,System.String,System.String,System.Boolean)">
            <summary>
            Extract the contents of a zip file.
            </summary>
            <param name="zipFileName">The zip file to extract from.</param>
            <param name="targetDirectory">The directory to save extracted information in.</param>
            <param name="overwrite">The style of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite">overwriting</see> to apply.</param>
            <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
            <param name="fileFilter">A filter to apply to files.</param>
            <param name="directoryFilter">A filter to apply to directories.</param>
            <param name="restoreDateTime">Flag indicating wether to restore the date and time for extracted files.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory">
            <summary>
            Defines factory methods for creating new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> values.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file given its name
            </summary>
            <param name="fileName">The name of the file to create an entry for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String,System.Boolean)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file given its name
            </summary>
            <param name="fileName">The name of the file to create an entry for.</param>
            <param name="useFileSystem">If true get details from the file system if the file exists.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a directory given its name
            </summary>
            <param name="directoryName">The name of the directory to create an entry for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a directory given its name
            </summary>
            <param name="directoryName">The name of the directory to create an entry for.</param>
            <param name="useFileSystem">If true get details from the file system for this directory if it exists.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.NameTransform">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"></see> applicable.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.UseZip64">
            <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.Off">
            <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
            <remarks>An entry can have this overridden if required <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ForceZip64"></see></remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.On">
            <summary>
            Zip64 should always be used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.Dynamic">
            <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.CompressionMethod">
            <summary>
            The kind of compression used for an entry in an archive
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Stored">
            <summary>
            A direct copy of the file contents is held in the archive
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary 
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflate64">
            <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.BZip2">
            <summary>
            Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.WinZipAES">
            <summary>
            WinZip special for AES encryption, Not supported by #Zip
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm">
            <summary>
            Identifies the encryption algorithm used for an entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption has been used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.PkzipClassic">
            <summary>
            Encrypted using PKZIP 2.0 or 'classic' encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Des">
            <summary>
            DES encryption has been used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC2">
            <summary>
            RCS encryption has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes168">
            <summary>
            Triple DES encryption with 168 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes112">
            <summary>
            Triple DES with 112 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes128">
            <summary>
            AES 128 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes192">
            <summary>
            AES 192 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes256">
            <summary>
            AES 256 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC2Corrected">
            <summary>
            RC2 corrected has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Blowfish">
            <summary>
            Blowfish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Twofish">
            <summary>
            Twofish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC4">
            <summary>
            RCS has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Unknown">
            <summary>
            An unknown algorithm has been used for encryption.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and 
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See [see cref="ZipEntry.CanDecompress"/].
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VERSION_MADE_BY">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See [see] cref="ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry[/see].
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EXTHDR">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENHDR">
            <summary>
            Size of central header entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
            <summary>
            Size of cryptographic header stored before entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LOCSIG">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SPANNINGSIG">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SPANTEMPSIG">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EXTSIG">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENSIG">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENSIG64">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENDIGITALSIG">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ENDSIG">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
            <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Dont use unicode encodings if you want to be Zip compatible!
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string.
            </summary>		
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[length - 1] converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.#ctor">
            <summary>
            Initialise default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipConstants">ZipConstants</see>
            </summary>
            <remarks>
            Private to prevent instances being created.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.HostSystemID">
            <summary>
            Defines known values for the <see cref="T:ICCEmbedded.SharpZipLib.Zip.HostSystemID"/> property.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Msdos">
            <summary>
            Host system = MSDOS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Amiga">
            <summary>
            Host system = Amiga
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OpenVms">
            <summary>
            Host system = Open VMS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Unix">
            <summary>
            Host system = Unix
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.VMCms">
            <summary>
            Host system = VMCms
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AtariST">
            <summary>
            Host system = Atari ST
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OS2">
            <summary>
            Host system = OS2
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Macintosh">
            <summary>
            Host system = Macintosh
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.ZSystem">
            <summary>
            Host system = ZSystem
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Cpm">
            <summary>
            Host system = Cpm
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.WindowsNT">
            <summary>
            Host system = Windows NT
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.MVS">
            <summary>
            Host system = MVS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Vse">
            <summary>
            Host system = VSE
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AcornRisc">
            <summary>
            Host system = Acorn RISC
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Vfat">
            <summary>
            Host system = VFAT
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AlternateMvs">
            <summary>
            Host system = Alternate MVS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.BeOS">
            <summary>
            Host system = BEOS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Tandem">
            <summary>
            Host system = Tandem
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OS400">
            <summary>
            Host system = OS400
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OSX">
            <summary>
            Host system = OSX
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.WinZipAES">
            <summary>
            Host system = WinZIP AES
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">
            <summary>
            This class represents an entry in a zip archive.  This can be a file
            or a directory
            ZipFile and ZipInputStream will give you instances of this class as 
            information about the members in an archive.  ZipOutputStream
            uses an instance of this class when creating an entry in a Zip file.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
            <summary>
            Creates a zip entry with the given name.
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix' style paths with relative names only.
            There are with no device names and path elements are separated by '/' characters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32)">
            <summary>
            Creates a zip entry with the given name and version required to extract
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix'  style paths with no device names and 
            path elements separated by '/' characters.  This is not enforced see <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">CleanName</see>
            on how to ensure names are valid if this is desired.
            </param>
            <param name="versionRequiredToExtract">
            The minimum 'feature version' required this entry
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32,System.Int32,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Initializes an entry with the given name and made by information
            </summary>
            <param name="name">Name for this entry</param>
            <param name="madeByInfo">Version and HostSystem Information</param>
            <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
            <param name="method">Compression method for this entry.</param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            versionRequiredToExtract should be 0 (auto-calculate) or > 10
            </exception>
            <remarks>
            This constructor is used by the ZipFile class when reading from the central header
            It is not generally useful, use the constructor specifying the name only.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Creates a deep copy of the given zip entry.
            </summary>
            <param name="entry">
            The entry to copy.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HasCrc">
            <summary>
            Get a value indicating wether the entry has a CRC value available.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCrypted">
            <summary>
            Get/Set flag indicating if entry is encrypted.
            A simple helper routine to aid interpretation of <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see>
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
            <summary>
            Get / set a flag indicating wether entry name and comment text are
            encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CryptoCheckValue">
            <summary>
            Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">
            <summary>
            Get/Set general purpose bit flag for entry
            </summary>
            <remarks>
            General purpose bit flag<br/>
            <br/>
            Bit 0: If set, indicates the file is encrypted<br/>
            Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
            Imploding:<br/>
            Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
            Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
            <br/>
            Deflating:<br/>
              Bit 2    Bit 1<br/>
                0        0       Normal compression was used<br/>
                0        1       Maximum compression was used<br/>
                1        0       Fast compression was used<br/>
                1        1       Super fast compression was used<br/>
            <br/>
            Bit 3: If set, the fields crc-32, compressed size
            and uncompressed size are were not able to be written during zip file creation
            The correct values are held in a data descriptor immediately following the compressed data. <br/>
            Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
            Bit 5: If set indicates the file contains compressed patch data<br/>
            Bit 6: If set indicates strong encryption was used.<br/>
            Bit 7-10: Unused or reserved<br/>
            Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
            Bit 12-15: Unused or reserved<br/>
            </remarks>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsUnicodeText"></seealso>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCrypted"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
            <summary>
            Get/Set index of this entry in Zip file
            </summary>
            <remarks>This is only valid when the entry is part of a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"></see></remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Offset">
            <summary>
            Get/set offset for use in central header
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
            <summary>
            Get/Set external file attributes as an integer.
            The values of this are operating system dependant see
            <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
            <summary>
            Get the version made by for this entry or zero if unknown.
            The value / 10 indicates the major version number, and 
            the value mod 10 is the minor version number
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsDOSEntry">
            <summary>
            Get a value indicating this entry is for a DOS/Windows system.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HasDosAttributes(System.Int32)">
            <summary>
            Test the external attributes for this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to
            see if the external attributes are Dos based (including WINNT and variants)
            and match the values
            </summary>
            <param name="attributes">The attributes to test.</param>
            <returns>Returns true if the external attributes are known to be DOS/Windows 
            based and have the same attributes set as the value passed.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HostSystem">
            <summary>
            Gets the compatability information for the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
            If the external file attributes are compatible with MS-DOS and can be read
            by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
            will be non-zero and identify the host system on which the attributes are compatible.
            </summary>
            		
            <remarks>
            The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
            misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
            to obtain up to date and correct information.  The modified appnote by the infozip group is
            particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
            <list type="table">
            <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
            <item>1 - Amiga</item>
            <item>2 - OpenVMS</item>
            <item>3 - Unix</item>
            <item>4 - VM/CMS</item>
            <item>5 - Atari ST</item>
            <item>6 - OS/2 HPFS</item>
            <item>7 - Macintosh</item>
            <item>8 - Z-System</item>
            <item>9 - CP/M</item>
            <item>10 - Windows NTFS</item>
            <item>11 - MVS (OS/390 - Z/OS)</item>
            <item>12 - VSE</item>
            <item>13 - Acorn Risc</item>
            <item>14 - VFAT</item>
            <item>15 - Alternate MVS</item>
            <item>16 - BeOS</item>
            <item>17 - Tandem</item>
            <item>18 - OS/400</item>
            <item>19 - OS/X (Darwin)</item>
            <item>99 - WinZip AES</item>
            <item>remainder - unused</item>
            </list>
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Version">
            <summary>
            Get minimum Zip feature version required to extract this entry
            </summary>		
            <remarks>
            Minimum features are defined as:<br/>
            1.0 - Default value<br/>
            1.1 - File is a volume label<br/>
            2.0 - File is a folder/directory<br/>
            2.0 - File is compressed using Deflate compression<br/>
            2.0 - File is encrypted using traditional encryption<br/>
            2.1 - File is compressed using Deflate64<br/>
            2.5 - File is compressed using PKWARE DCL Implode<br/>
            2.7 - File is a patch data set<br/>
            4.5 - File uses Zip64 format extensions<br/>
            4.6 - File is compressed using BZIP2 compression<br/>
            5.0 - File is encrypted using DES<br/>
            5.0 - File is encrypted using 3DES<br/>
            5.0 - File is encrypted using original RC2 encryption<br/>
            5.0 - File is encrypted using RC4 encryption<br/>
            5.1 - File is encrypted using AES encryption<br/>
            5.1 - File is encrypted using corrected RC2 encryption<br/>
            5.1 - File is encrypted using corrected RC2-64 encryption<br/>
            6.1 - File is encrypted using non-OAEP key wrapping<br/>
            6.2 - Central directory encryption (not confirmed yet)<br/>
            6.3 - File is compressed using LZMA<br/>
            6.3 - File is compressed using PPMD+<br/>
            6.3 - File is encrypted using Blowfish<br/>
            6.3 - File is encrypted using Twofish<br/>
            </remarks>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CanDecompress"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CanDecompress">
            <summary>
            Get a value indicating wether this entry can be decompressed by the library.
            </summary>
            <remarks>This is based on the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Version"></see> and 
            wether the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ForceZip64">
            <summary>
            Force this entry to be recorded using Zip64 extensions.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
            <summary>
            Get a value indicating wether Zip64 extensions were forced.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
            <summary>
            Gets a value indicating if the entry requires Zip64 extensions 
            to store the full entry values.
            </summary>
            <value>A <see cref="T:System.Boolean"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
            <summary>
            Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DosTime">
            <summary>
            Get/Set DosTime value.
            </summary>
            <remarks>
            The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime">
            <summary>
            Gets/Sets the time of last modification of the entry.
            </summary>
            <remarks>
            The <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Name">
             <summary>
             Returns the entry name.
             </summary>
             <remarks>
             The unix naming convention is followed.
             Path components in the entry should always separated by forward slashes ('/').
             Dos device names like C: should also be removed.
             See the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"/> class, or <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)"/>
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Size">
            <summary>
            Gets/Sets the size of the uncompressed data.
            </summary>
            <returns>
            The size or -1 if unknown.
            </returns>
            <remarks>Setting the size before adding an entry to an archive can help
            avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressedSize">
            <summary>
            Gets/Sets the size of the compressed data.
            </summary>
            <returns>
            The compressed entry size or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Crc">
            <summary>
            Gets/Sets the crc of the uncompressed data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Crc is not in the range 0..0xffffffffL
            </exception>
            <returns>
            The crc value or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressionMethod">
            <summary>
            Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
            <returns>
            The compression method for this entry
            </returns>
            <see cref="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflated"/>
            <see cref="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Stored"/>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExtraData">
            <summary>
            Gets/Sets the extra data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Extra data is longer than 64KB (0xffff) bytes.
            </exception>
            <returns>
            Extra data or null if not set.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ProcessExtraData(System.Boolean)">
            <summary>
            Process extra data fields updating the entry based on the contents.
            </summary>
            <param name="localHeader">True if the extra data fields should be handled
            for a local header, rather than for a central header.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Comment">
            <summary>
            Gets/Sets the entry comment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If comment is longer than 0xffff.
            </exception>
            <returns>
            The comment or null if not set.
            </returns>
            <remarks>
            A comment is only available for entries when read via the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> class.
            The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipInputStream"/> class doesnt have the comment data available.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsDirectory">
            <summary>
            Gets a value indicating if the entry is a directory.
            however.
            </summary>
            <remarks>
            A directory is determined by an entry name with a trailing slash '/'.
            The external file attributes can also indicate an entry is for a directory.
            Currently only dos/windows attributes are tested in this manner.
            The trailing slash convention should always be followed.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsFile">
            <summary>
            Get a value of true if the entry appears to be a file; false otherwise
            </summary>
            <remarks>
            This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
            For linux and others the result may be incorrect.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
            <summary>
            Test entry to see if data can be extracted.
            </summary>
            <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Clone">
            <summary>
            Creates a copy of this zip entry.
            </summary>
            <returns>An <see cref="T:System.Object"/> that is a copy of the current instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ToString">
            <summary>
            Gets a string representation of this ZipEntry.
            </summary>
            <returns>A readable textual representation of this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Test a <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
            supports extracting data compressed with that method
            </summary>
            <param name="method">The compression method to test.</param>
            <returns>Returns true if the compression method is supported; false otherwise</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
            <summary>
            Cleans a name making it conform to Zip file conventions.
            Devices names ('c:\') and UNC share names ('\\server\share') are removed
            and forward slashes ('\') are converted to back slashes ('/').
            Names are made relative by trimming leading slashes which is compatible
            with the ZIP naming convention.
            </summary>
            <param name="name">The name to clean</param>
            <returns>The 'cleaned' name.</returns>
            <remarks>
            The <seealso cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">Zip name transform</seealso> class is more flexible.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory">
            <summary>
            Basic implementation of <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"></see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">
            <summary>
            Defines the possible values to be used for the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime"/>.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTime">
            <summary>
            Use the recorded LastWriteTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTimeUtc">
            <summary>
            Use the recorded LastWriteTimeUtc value for the file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTime">
            <summary>
            Use the recorded CreateTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTimeUtc">
            <summary>
            Use the recorded CreateTimeUtc value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTime">
            <summary>
            Use the recorded LastAccessTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTimeUtc">
            <summary>
            Use the recorded LastAccessTimeUtc value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed">
            <summary>
            Use a fixed value.
            </summary>
            <remarks>The actual <see cref="T:System.DateTime"/> value used can be
            specified via the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)"/> constructor or 
            using the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)"/> with the setting set
            to <see cref="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed"/> which will use the <see cref="T:System.DateTime"/> when this class was constructed.
            The <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime"/> property can also be used to set this value.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor">
            <summary>
            Initialise a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> class.
            </summary>
            <remarks>A default <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/>, and the LastWriteTime for files is used.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> using the specified <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting"/>
            </summary>
            <param name="timeSetting">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">time setting</see> to use when creating <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">Zip entries</see>.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> using the specified <see cref="T:System.DateTime"/>
            </summary>
            <param name="time">The time to set all <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime"/> values to.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.NameTransform">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/> to be used when creating new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> values.
            </summary>
            <remarks>
            Setting this property to null will cause a default <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">name transform</see> to be used.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.Setting">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting"/> in use.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime">
            <summary>
            Get / set the <see cref="T:System.DateTime"/> value to use when <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.Setting"/> is set to <see cref="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.GetAttributes">
            <summary>
            A bitmask defining the attributes to be retrieved from the actual file.
            </summary>
            <remarks>The default is to get all possible attributes from the actual file.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.SetAttributes">
            <summary>
            A bitmask defining which attributes are to be set on.
            </summary>
            <remarks>By default no attributes are set on.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.IsUnicodeText">
            <summary>
            Get set a value indicating wether unidoce text should be set on.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file.
            </summary>
            <param name="fileName">The name of the file to create a new entry for.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String,System.Boolean)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> from a name.
            </summary>
            <param name="fileName">The name of the file to create a new entry for.</param>
            <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
            <param name="directoryName">The raw untransformed name for the new directory</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
            <param name="directoryName">The raw untransformed name for the new directory</param>
            <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            <summary>
            Represents exception conditions specific to Zip archive handling
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor">
            <summary>
            Initializes a new instance of the ZipException class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ZipException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of ZipException.
            </summary>
            <param name="message">A message describing the error.</param>
            <param name="exception">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">
            <summary>
            ExtraData tagged value interface.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ITaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the contents of this instance from the data passed.
            </summary>
            <param name="data">The data to extract contents from.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedData.GetData">
            <summary>
            Get the data representing this instance.
            </summary>
            <returns>Returns the data for this instance.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.RawTaggedData">
            <summary>
            A raw binary tagged value
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.#ctor(System.Int16)">
            <summary>
            Initialise a new instance.
            </summary>
            <param name="tag">The tag ID.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="offset">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.Data">
            <summary>
            Get /set the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.tag_">
            <summary>
            The tag ID for this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData">
            <summary>
            Class representing extended unix date time values.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags">
            <summary>
            Flags indicate which values are included in this instance.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.ModificationTime">
            <summary>
            The modification time is included
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.AccessTime">
            <summary>
            The access time is included
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.CreateTime">
            <summary>
            The create time is included.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.TagID">
            <summary>
            Get the ID
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.ModificationTime">
            <summary>
            Get /set the Modification Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.AccessTime">
            <summary>
            Get / set the Access Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.CreateTime">
            <summary>
            Get / Set the Create Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Include">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.NTTaggedData">
            <summary>
            Class handling NT date time values.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.LastModificationTime">
            <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.CreateTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">create time</see>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.LastAccessTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ITaggedDataFactory">
            <summary>
            A factory that creates <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged data</see> instances.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get data for a specific tag value.
            </summary>
            <param name="tag">The tag ID to find.</param>
            <param name="data">The data to search.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
            <returns>The located <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">value found</see>, or null if not found.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipExtraData">
            
            <summary>
            A class to handle the extra data field for Zip entries
            </summary>
            <remarks>
            Extra data contains 0 or more values each prefixed by a header tag and length.
            They contain zero or more bytes of actual data.
            The data is held internally using a copy on write strategy.  This is more efficient but
            means that for extra data created by passing in data can have the values modified by the caller
            in some circumstances.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.#ctor">
            <summary>
            Initialise a default instance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
            <summary>
            Initialise with known extra data.
            </summary>
            <param name="data">The extra data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetEntryData">
            <summary>
            Get the raw extra data value
            </summary>
            <returns>Returns the raw byte[] extra data this instance represents.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Clear">
            <summary>
            Clear the stored data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Length">
            <summary>
            Gets the current extra data length.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
            <summary>
            Get a read-only <see cref="T:System.IO.Stream"/> for the associated tag.
            </summary>
            <param name="tag">The tag to locate data for.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> containing tag data or null if no tag was found.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetData(System.Int16)">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
            <param name="tag">The tag to search for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ValueLength">
            <summary>
            Get the length of the last value found by <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/>
            </summary>
            <remarks>This is only value if <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previsouly returned true.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
            <summary>
            Get the index for the current read value.
            </summary>
            <remarks>This is only valid if <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.
            Initially it will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadInt"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort"/> and <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadLong"/>. </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.UnreadCount">
            <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
            <summary>
            Find an extra data value
            </summary>
            <param name="headerID">The identifier for the value to find.</param>
            <returns>Returns true if the value was found; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(ICCEmbedded.SharpZipLib.Zip.ITaggedData)">
            <summary>
            Add a new entry to extra data.
            </summary>
            <param name="taggedData">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData"/> value to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
            <summary>
            Add a new entry to extra data
            </summary>
            <param name="headerID">The ID for this entry.</param>
            <param name="fieldData">The data to add.</param>
            <remarks>If the ID already exists its contents are replaced.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
            <summary>
            Start adding a new entry.
            </summary>
            <remarks>Add data using <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)"/>, or <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)"/>.
            The new entry is completed and actually added by calling <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)"/></remarks>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(ICCEmbedded.SharpZipLib.Zip.ITaggedData)"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
            <summary>
            Add entry data added since <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/> using the ID passed.
            </summary>
            <param name="headerID">The identifier to use for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
            <summary>
            Add a byte of data to the pending new entry.
            </summary>
            <param name="data">The byte to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
            <summary>
            Add data to a pending new entry.
            </summary>
            <param name="data">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
            <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
            <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
            <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
            <summary>
            Delete an extra data field.
            </summary>
            <param name="headerID">The identifier of the field to delete.</param>
            <returns>Returns true if the field was found and deleted.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadLong">
            <summary>
            Read a long in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
            <returns>Returns the long value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadInt">
            <summary>
            Read an integer in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the integer read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort">
            <summary>
            Read a short value in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadByte">
            <summary>
            Read a byte from an extra data
            </summary>
            <returns>The byte value read or -1 if the end of data has been reached.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
            <summary>
            Skip data during reading.
            </summary>
            <param name="amount">The number of bytes to skip.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShortInternal">
            <summary>
            Internal form of <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort"/> that reads data at any location.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs">
            <summary>
            Arguments used with KeysRequiredEvent
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs"></see>
            </summary>
            <param name="name">The name of the file for which keys are required.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String,System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs"></see>
            </summary>
            <param name="name">The name of the file for which keys are required.</param>
            <param name="keyValue">The current key value.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.FileName">
            <summary>
            Get the name of the file for which keys are required.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.Key">
            <summary>
            Get/set the key value
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestStrategy">
            <summary>
            The strategy to apply to testing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestStrategy.FindFirstError">
            <summary>
            Find the first error only.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestStrategy.FindAllErrors">
            <summary>
            Find all possible errors.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestOperation">
            <summary>
            The operation in progress reported by a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.Initialising">
            <summary>
            Setting up testing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryHeader">
            <summary>
            Testing an individual entries header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryData">
            <summary>
            Testing an individual entries data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryComplete">
            <summary>
            Testing an individual entry has completed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.MiscellaneousTests">
            <summary>
            Running miscellaneous tests
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.Complete">
            <summary>
            Testing is complete
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestStatus">
            <summary>
            Status returned returned by <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.TestStatus.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStatus"/>
            </summary>
            <param name="file">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> this status applies to.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.Operation">
            <summary>
            Get the current <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestOperation"/> in progress.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.File">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> this status is applicable to.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.Entry">
            <summary>
            Get the current/last entry tested.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.ErrorCount">
            <summary>
            Get the number of errors detected so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.BytesTested">
            <summary>
            Get the number of bytes tested so far for the current entry.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.EntryValid">
            <summary>
            Get a value indicating wether the last entry test was valid.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler">
            <summary>
            Delegate invoked during <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICCEmbedded.SharpZipLib.Zip.TestStrategy,ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
            </summary>
            <remarks>If the message is non-null an error has occured.  If the message is null
            the operation as found in <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStatus">status</see> has started.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode">
            <summary>
            The possible ways of <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">applying updates</see> to an archive.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode.Safe">
            <summary>
            Perform all updates on temporary files ensuring that the original file is saved.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode.Direct">
            <summary>
            Update the archive directly, which is faster but less safe.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile">
            <summary>
            This class represents a Zip archive.  You can ask for the contained
            entries, or get an input stream for a file entry.  The entry is
            automatically decompressed.
            
            You can also update the archive adding or deleting entries.
            
            This class is thread safe for input:  You can open input streams for arbitrary
            entries in different threads.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
            <example>
            <code>
            using System;
            using System.Text;
            using System.Collections;
            using System.IO;
            
            using ICCEmbedded.SharpZipLib.Zip;
            
            class MainClass
            {
            	static public void Main(string[] args)
            	{
            		using (ZipFile zFile = new ZipFile(args[0])) {
            			Console.WriteLine("Listing of : " + zFile.Name);
            			Console.WriteLine("");
            			Console.WriteLine("Raw Size    Size      Date     Time     Name");
            			Console.WriteLine("--------  --------  --------  ------  ---------");
            			foreach (ZipEntry e in zFile) {
            				if ( e.IsFile ) {
            					DateTime d = e.DateTime;
            					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
            						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
            						e.Name);
            				}
            			}
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.KeysRequiredEventHandler">
            <summary>
            Delegate for handling keys/password setting during compresion/decompression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipFile.KeysRequired">
            <summary>
            Event handler for handling encryption keys.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.OnKeysRequired(System.String)">
            <summary>
            Handles getting of encryption keys when required.
            </summary>
            <param name="fileName">The file for which encryption keys are required.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Key">
            <summary>
            Get/set the encryption key value.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Password">
            <summary>
            Password to be used for encrypting/decrypting files.
            </summary>
            <remarks>Set to null if no password is required.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.HaveKeys">
            <summary>
            Get a value indicating wether encryption keys are currently available.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.String)">
            <summary>
            Opens a Zip file with the given name for reading.
            </summary>
            <param name="name">The name of the file to open.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.IO.FileStream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.FileStream"/>.
            </summary>
            <param name="file">The <see cref="T:System.IO.FileStream"/> to read archive data from.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.IO.Stream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read archive data from.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.<br/>
            The stream provided cannot seek
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor">
            <summary>
            Initialises a default <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> instance with no entries and no file storage.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Finalize">
            <summary>
            Finalize this instance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Close">
            <summary>
            Closes the ZipFile.  If the stream is <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsStreamOwner">owned</see> then this also closes the underlying input stream.
            Once closed, no further instance methods should be called.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Create(System.String)">
            <summary>
            Create a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> whose data will be stored in a file.
            </summary>
            <param name="fileName">The name of the archive to create.</param>
            <returns>Returns the newly created <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Create(System.IO.Stream)">
            <summary>
            Create a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> whose data will be stored on a stream.
            </summary>
            <param name="outStream">The stream providing data storage.</param>
            <returns>Returns the newly created <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/></returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsStreamOwner">
            <summary>
            Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
            If the flag is true then the stream will be closed when <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Close">Close</see> is called.
            </summary>
            <remarks>
            The default value is true in all cases.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsEmbeddedArchive">
            <summary>
            Get a value indicating wether
            this archive is embedded in another file or not.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsNewArchive">
            <summary>
            Get a value indicating that this archive is a new one.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipFileComment">
            <summary>
            Gets the comment for the zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Name">
            <summary>
            Gets the name of this zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Size">
            <summary>
            Gets the number of entries in this zip file.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Count">
            <summary>
            Get the number of entries contained in this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.EntryByIndex(System.Int32)">
            <summary>
            Indexer property for ZipEntries
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetEnumerator">
            <summary>
            Gets an enumerator for the Zip entries in this Zip file.
            </summary>
            <returns>Returns an <see cref="T:System.Collections.IEnumerator"/> for this archive.</returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.FindEntry(System.String,System.Boolean)">
            <summary>
            Return the index of the entry with a matching name
            </summary>
            <param name="name">Entry name to find</param>
            <param name="ignoreCase">If true the comparison is case insensitive</param>
            <returns>The index position of the matching entry or -1 if not found</returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetEntry(System.String)">
            <summary>
            Searches for a zip entry in this archive with the given name.
            String comparisons are case insensitive
            </summary>
            <param name="name">
            The name to find. May contain directory components separated by slashes ('/').
            </param>
            <returns>
            A clone of the zip entry, or null if no entry with that name exists.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetInputStream(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Gets an input stream for reading the given zip entry data in an uncompressed form.
            Normally the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> should be an entry returned by GetEntry().
            </summary>
            <param name="entry">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to obtain a data <see cref="T:System.IO.Stream"/> for</param>
            <returns>An input <see cref="T:System.IO.Stream"/> containing data for this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/></returns>
            <exception cref="T:System.InvalidOperationException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetInputStream(System.Int64)">
            <summary>
            Creates an input stream reading a zip entry
            </summary>
            <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
            <returns>
            An input <see cref="T:System.IO.Stream"/> containing data for this <paramref name="entryIndex"/>
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <returns>true if all tests pass, false otherwise</returns>
            <remarks>Testing will terminate on the first error found.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICCEmbedded.SharpZipLib.Zip.TestStrategy,ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <param name="strategy">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStrategy"></see> to apply.</param>
            <param name="resultHandler">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"></see> handler to call during testing.</param>
            <returns>true if all tests pass, false otherwise</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestLocalHeader(ICCEmbedded.SharpZipLib.Zip.ZipEntry,ICCEmbedded.SharpZipLib.Zip.ZipFile.HeaderTest)">
            <summary>
            Test a local header against that provided from the central directory
            </summary>
            <param name="entry">
            The entry to test against
            </param>
            <param name="tests">The type of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.HeaderTest">tests</see> to carry out.</param>
            <returns>The offset of the entries data in the file</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateCommand">
            <summary>
            The kind of update to apply.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.NameTransform">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/> to apply to names when updating.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.EntryFactory">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"/> used to generate <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> values
            during updates.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.BufferSize">
            <summary>
            Get /set the buffer size to be used when updating this zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsUpdating">
            <summary>
            Get a value indicating an update has <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate">been started</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UseZip64">
            <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage,ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource)">
            <summary>
            Begin updating this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <param name="archiveStorage">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage">archive storage</see> for use during the update.</param>
            <param name="dataSource">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource">data source</see> to utilise during updating.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage)">
            <summary>
            Begin updating to this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <param name="archiveStorage">The storage to use during the update.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate">
            <summary>
            Begin updating this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage)"/>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">
            <summary>
            Commit current updates, updating this archive.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate">
            <summary>
            Abort updating leaving the archive unchanged.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.SetComment(System.String)">
            <summary>
            Set the file comment to be recorded when the current update is <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">commited</see>.
            </summary>
            <param name="comment">The comment to record.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
            <summary>
            Add a new entry to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
            <param name="compressionMethod">The compression method to use.</param>
            <param name="useUnicodeText">Ensure Unicode text is used for name and comment for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Add a new entry to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
            <param name="compressionMethod">The compression method to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String)">
            <summary>
            Add a file to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
            <param name="compressionMethod">The compression method to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
            <param name="compressionMethod">The compression method to use.</param>
            <param name="useUnicodeText">Ensure Unicode text is used for name and comments for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Add a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> that contains no data.
            </summary>
            <param name="entry">The entry to add.</param>
            <remarks>This can be used to add directories, volume labels, or empty file entries.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AddDirectory(System.String)">
            <summary>
            Add a directory entry to the archive.
            </summary>
            <param name="directoryName">The directory to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Delete(System.String)">
            <summary>
            Delete an entry by name
            </summary>
            <param name="fileName">The filename to delete</param>
            <returns>True if the entry was found and deleted; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Delete(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Delete a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> from the archive.
            </summary>
            <param name="entry">The entry to delete.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEUshort(System.UInt16)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEUint(System.UInt32)">
            <summary>
            Write an unsigned int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLeLong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetBuffer">
            <summary>
            Get a raw memory buffer.
            </summary>
            <returns>Returns a raw memory buffer.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetDescriptorSize(ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate)">
            <summary>
            Get the size of the source descriptor for a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate"/>.
            </summary>
            <param name="update">The update to get the size for.</param>
            <returns>The descriptor size, zero if there isnt one.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetOutputStream(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Get an output stream for the specified <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/>
            </summary>
            <param name="entry">The entry to get an output stream for.</param>
            <returns>The output stream obtained for the entry.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateComparer">
            <summary>
            Class used to sort updates.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateComparer.Compare(System.Object,System.Object)">
            <summary>
            Compares two objects and returns a value indicating whether one is 
            less than, equal to or greater than the other.
            </summary>
            <param name="x">First object to compare</param>
            <param name="y">Second object to compare.</param>
            <returns>Compare result.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate">
            <summary>
            Represents a pending update to a Zip file.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Copy an existing entry.
            </summary>
            <param name="entry">The existing entry to copy.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Entry">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for this update.
            </summary>
            <remarks>This is the source or original entry.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.OutEntry">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> that will be written to the updated/new file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Command">
            <summary>
            Get the command for this update.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Filename">
            <summary>
            Get the filename if any for this update.  Null if none exists.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.SizePatchOffset">
            <summary>
            Get/set the location of the size patch for this update.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.CrcPatchOffset">
            <summary>
            Get /set the location of the crc patch for this update.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadLEUshort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadLEUint">
            <summary>
            Read a uint in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadEntries">
            <summary>
            Search for and read the central directory of a zip file filling the entries array.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The central directory is malformed or cannot be found
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.LocateEntry(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Locate the data for a given entry.
            </summary>
            <returns>
            The start offset of the data.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The local header signature is invalid, the entry and central header file name lengths are different
            or the local and entry compression methods dont match
            </exception>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString">
            <summary>
            Represents a string from a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> which is stored as an array of bytes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.#ctor(System.String)">
            <summary>
            Initialise a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> with a string.
            </summary>
            <param name="comment">The textual string form.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.#ctor(System.Byte[])">
            <summary>
            Initialise a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> using a string in its binary 'raw' form.
            </summary>
            <param name="rawString"></param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.IsSourceString">
            <summary>
            Get a value indicating the original source of data for this instance.
            True if the source was a string; false if the source was binary data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.RawLength">
            <summary>
            Get the length of the comment when represented as raw bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.RawComment">
            <summary>
            Get the comment in its 'raw' form as plain bytes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.Reset">
            <summary>
            Reset the comment to its initial state.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.op_Implicit(ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString)~System.String">
            <summary>
            Implicit conversion of comment to a string.
            </summary>
            <param name="zipString">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> to convert to a string.</param>
            <returns>The textual equivalent for the input value.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipEntryEnumerator">
            <summary>
            An <see cref="T:System.Collections.IEnumerator">enumerator</see> for <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">Zip entries</see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream"/> is a stream that you can write uncompressed data
            to and flush, but cannot read, seek or do anything else to.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Close">
            <summary>
            Close this stream instance.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Flush">
            <summary>
            Write any buffered data to underlying storage.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanWrite">
            <summary>
            Gets a value indicating whether the current stream supports writing.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanSeek">
            <summary>
            Gets a value indicating whether the current stream supports seeking.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Length">
            <summary>
            Get the length in bytes of the stream.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Position">
            <summary>
            Gets or sets the position within the current stream.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream">
            <summary>
            A <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream"/> is an <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            whose data is only a part or subsection of a file.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream"/> class.
            </summary>
            <param name="baseStream">The underlying stream to use for IO.</param>
            <param name="start">The start of the partial data.</param>
            <param name="length">The length of the partial data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.SkipBytes(System.Int64)">
            <summary>
            Skip the specified number of input bytes.
            </summary>
            <param name="count">The maximum number of input bytes to skip.</param>
            <returns>The actuial number of input bytes skipped.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.ReadByte">
            <summary>
            Read a byte from this stream.
            </summary>
            <returns>Returns the byte read or -1 on end of stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.Close">
            <summary>
            Close this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream">partial input stream</see>.
            </summary>
            <remarks>
            The underlying stream is not closed.  Close the parent ZipFile class to do that.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource">
            <summary>
            Provides a static way to obtain a source of data for an entry.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource.GetSource">
            <summary>
            Get a source of data by creating a new stream.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> to use for compression input.</returns>
            <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource">
            <summary>
            Represents a source of data that can dynamically provide
            multiple <see cref="T:System.IO.Stream">data sources</see> based on the parameters passed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource.GetSource(ICCEmbedded.SharpZipLib.Zip.ZipEntry,System.String)">
            <summary>
            Get a data source.
            </summary>
            <param name="entry">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to get a source for.</param>
            <param name="name">The name for data if known.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> to use for compression input.</returns>
            <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource">
            <summary>
            Default implementation of a <see cref="T:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource"/> for use with files stored on disk.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource.#ctor(System.String)">
            <summary>
            Initialise a new instnace of <see cref="T:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource"/>
            </summary>
            <param name="fileName">The name of the file to obtain data from.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource.GetSource">
            <summary>
            Get a <see cref="T:System.IO.Stream"/> providing data.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> provising data.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource">
            <summary>
            Default implementation of <see cref="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource"/> for files stored on disk.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource"/>.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource.GetSource(ICCEmbedded.SharpZipLib.Zip.ZipEntry,System.String)">
            <summary>
            Get a <see cref="T:System.IO.Stream"/> providing data for an entry.
            </summary>
            <param name="entry">The entry to provide data for.</param>
            <param name="name">The file name for data if known.</param>
            <returns>Returns a stream providing data; or null if not available</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage">
            <summary>
            Defines facilities for data storage when updating Zip Archives.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.UpdateMode">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode"/> to apply during updates.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput">
            <summary>
            Get an empty <see cref="T:System.IO.Stream"/> that can be used for temporary output.
            </summary>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/></returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Convert a temporary output stream to a final stream.
            </summary>
            <returns>The resulting final <see cref="T:System.IO.Stream"/></returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of the original stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The current stream.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>This may be the current stream passed.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage">
            <summary>
            An abstract <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> suitable for extension by inheritance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage"/> class.
            </summary>
            <param name="updateMode">The update mode.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets a temporary output <see cref="T:System.IO.Stream"/>
            </summary>
            <returns>Returns the temporary output stream.</returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts the temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to make a copy of.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to open for direct update.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.UpdateMode">
            <summary>
            Gets the update mode applicable.
            </summary>
            <value>The update mode.</value>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> implementation suitable for hard disks.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile,ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage"/> class.
            </summary>
            <param name="file">The file.</param>
            <param name="updateMode">The update mode.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage"/> class.
            </summary>
            <param name="file">The file.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets a temporary output <see cref="T:System.IO.Stream"/> for performing updates on.
            </summary>
            <returns>Returns the temporary output stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts a temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of a stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="current">The current stream.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>If the <paramref name="current"/> stream is not null this is used as is.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> implementation suitable for in memory streams.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage"/> class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage"/> class.
            </summary>
            <param name="updateMode">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode"/> to use</param>
            <remarks>This constructor is for testing as memory streams dont really require safe mode.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.FinalStream">
            <summary>
            Get the stream returned by <see cref="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal"/> if this was in fact called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets the temporary output <see cref="T:System.IO.Stream"/>
            </summary>
            <returns>Returns the temporary output stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts the temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of the original stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The original source stream</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>If the <paramref name="stream"/> passed is not null this is used;
            otherwise a new <see cref="T:System.IO.MemoryStream"/> is returned.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DescriptorData">
            <summary>
            Holds data pertinent to a data descriptor.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.CompressedSize">
            <summary>
            Get /set the compressed size of data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.Size">
            <summary>
            Get / set the uncompressed size of data
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.Crc">
            <summary>
            Get /set the crc value.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream">
            <summary>
            This class assists with writing/reading from Zip files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.#ctor(System.String)">
            <summary>
            Initialise an instance of this class.
            </summary>
            <param name="name">The name of the file to open.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream"/>.
            </summary>
            <param name="stream">The stream to use.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner">
            <summary>
            Get / set a value indicating wether the the underlying stream is owned or not.
            </summary>
            <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            The underlying stream is closed only if <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner"/> is true.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.LocateBlockWithSignature(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            Locates a block with the desired <paramref name="signature"/>.
            </summary>
            <param name="signature">The signature to find.</param>
            <param name="endLocation">Location, marking the end of block.</param>
            <param name="minimumBlockSize">Minimum size of the block.</param>
            <param name="maximumVariableData">The maximum variable data.</param>
            <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteZip64EndOfCentralDirectory(System.Int64,System.Int64,System.Int64)">
            <summary>
            Write Zip64 end of central directory records (File header and locator).
            </summary>
            <param name="noOfEntries">The number of entries in the central directory.</param>
            <param name="sizeEntries">The size of entries in the central directory.</param>
            <param name="centralDirOffset">The offset of the dentral directory.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteEndOfCentralDirectory(System.Int64,System.Int64,System.Int64,System.Byte[])">
            <summary>
            Write the required records to end the central directory.
            </summary>
            <param name="noOfEntries">The number of entries in the directory.</param>
            <param name="sizeEntries">The size of the entries in the directory.</param>
            <param name="startOfCentralDirectory">The start of the central directory.</param>
            <param name="comment">The archive comment.  (This can be null).</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLEShort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLEInt">
            <summary>
            Read an int in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLELong">
            <summary>
            Read a long in little endian byte order.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUshort(System.UInt16)">
            <summary>
            Write a ushort in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUint(System.UInt32)">
            <summary>
            Write a uint in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLELong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUlong(System.UInt64)">
            <summary>
            Write a ulong in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteDataDescriptor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Write a data descriptor.
            </summary>
            <param name="entry">The entry to write a descriptor for.</param>
            <returns>Returns the number of descriptor bytes written.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadDataDescriptor(System.Boolean,ICCEmbedded.SharpZipLib.Zip.DescriptorData)">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
            <param name="zip64">if set to <c>true</c> [zip64].</param>
            <param name="data">The data to fill in.</param>
            <returns>Returns the number of bytes read in the descriptor.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipInputStream">
             <summary>
             This is an InflaterInputStream that reads the files baseInputStream an zip archive
             one after another.  It has a special method to get the zip entry of
             the next file.  The zip entry contains information about the file name
             size, compressed size, Crc, etc.
             It includes support for Stored and Deflated entries.
             <br/>
             <br/>Author of the original java version : Jochen Hoenicke
             </summary>
            
             <example> This sample shows how to read a zip file
             <code lang="C#">
             using System;
             using System.Text;
             using System.IO;
            
             using ICSharpCode.SharpZipLib.Zip;
            
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		using ( ZipInputStream s = new ZipInputStream(File.OpenRead(args[0]))) {
            
             			ZipEntry theEntry;
             			const int size = 2048;
             			byte[] data = new byte[2048];
            
             			while ((theEntry = s.GetNextEntry()) != null) {
                             if ( entry.IsFile ) {
             				    Console.Write("Show contents (y/n) ?");
             				    if (Console.ReadLine() == "y") {
             				    	while (true) {
             				    		size = s.Read(data, 0, data.Length);
             				    		if (size > 0) {
             				    			Console.Write(new ASCIIEncoding().GetString(data, 0, size));
             				    		} else {
             				    			break;
             				    		}
             				    	}
             				    }
             				}
             			}
             		}
             	}
             }
             </code>
             </example>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.ReadDataHandler">
            <summary>
            Delegate for reading bytes from a stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.internalReader">
            <summary>
            The current reader this instance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
            <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream"/> providing data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new Zip input stream, for reading a zip archive.
            </summary>
            <param name="baseInputStream">The underlying <see cref="T:System.IO.Stream"/> providing data.</param>
            <param name="bufferSize">Size of the buffer.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.Password">
            <summary>
            Optional password used for encryption when non-null
            </summary>
            <value>A password for all encrypted <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">entries </see> in this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipInputStream"/></value>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.CanDecompressEntry">
            <summary>
            Gets a value indicating if there is a current entry and it can be decompressed
            </summary>
            <remarks>
            The entry can only be decompressed if the library supports the zip features required to extract it.
            See the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Version">ZipEntry Version</see> property for more details.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.GetNextEntry">
            <summary>
            Advances to the next entry in the archive
            </summary>
            <returns>
            The next <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">entry</see> in the archive or null if there are no more entries.
            </returns>
            <remarks>
            If the previous entry is still open <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.CloseEntry">CloseEntry</see> is called.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Input stream is closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            Password is not set, password is invalid, compression method is invalid,
            version required to extract is not supported
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.ReadDataDescriptor">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.CompleteCloseEntry(System.Boolean)">
            <summary>
            Complete cleanup as the final part of closing.
            </summary>
            <param name="testCrc">True if the crc value should be tested</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.CloseEntry">
            <summary>
            Closes the current zip entry and moves to the next one.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The stream is closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The Zip stream ends early
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.Available">
            <summary>
            Returns 1 if there is an entry available
            Otherwise returns 0.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.Length">
            <summary>
            Returns the current size that can be read from the current entry if available
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">Thrown if the entry size is not known.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if no entry is currently available.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.ReadByte">
            <summary>
            Reads a byte from the current zip entry.
            </summary>
            <returns>
            The byte or -1 if end of stream is reached.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.ReadingNotAvailable(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle attempts to read by throwing an <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="destination">The destination array to store data in.</param>
            <param name="offset">The offset at which data read should be stored.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.ReadingNotSupported(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle attempts to read from this entry by throwing an exception
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.InitialRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Perform the initial read on an entry which may include
            reading encryption headers and setting up inflation.
            </summary>
            <param name="destination">The destination to fill with data read.</param>
            <param name="offset">The offset to start reading at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from the stream.
            </summary>
            <param name="buffer">The destination for the bytes.</param>
            <param name="offset">The index to start storing data.</param>
            <param name="count">The number of bytes to attempt to read.</param>
            <returns>Returns the number of bytes read.</returns>
            <remarks>Zero bytes read means end of stream.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.BodyRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a block of bytes from the current zip entry.
            </summary>
            <returns>
            The number of bytes read (this may be less than the length requested, even before the end of stream), or 0 on end of stream.
            </returns>
            <exception name="IOException">
            An i/o error occured.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The deflated stream is corrupted.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The stream is not open.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipInputStream.Dispose(System.Boolean)">
            <summary>
            Closes the zip input stream
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">
            <summary>
            ZipNameTransform transforms names as per the Zip file naming convention.
            </summary>
            <remarks>The use of absolute names is supported although its use is not valid 
            according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#ctor">
            <summary>
            Initialize a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"></see>
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#ctor(System.String)">
            <summary>
            Initialize a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"></see>
            </summary>
            <param name="trimPrefix">The string to trim from front of paths if found.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TransformDirectory(System.String)">
            <summary>
            Transform a directory name according to the Zip file naming conventions.
            </summary>
            <param name="name">The directory name to transform.</param>
            <returns>The transformed name.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TransformFile(System.String)">
            <summary>
            Transform a windows file name according to the Zip file naming conventions.
            </summary>
            <param name="name">The file name to transform.</param>
            <returns>The transformed name.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TrimPrefix">
            <summary>
            Get/set the path prefix to be trimmed from paths if present.
            </summary>
            <remarks>The prefix is trimmed before any conversion from
            a windows path is done.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.MakeValidName(System.String,System.Char)">
            <summary>
            Force a name to be valid by replacing invalid characters with a fixed value
            </summary>
            <param name="name">The name to force valid</param>
            <param name="replacement">The replacement character to use.</param>
            <returns>Returns a valid name</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String,System.Boolean)">
            <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
            <param name="name">The name to test.</param>
            <param name="relaxed">If true checking is relaxed about windows file names and absolute paths.</param>
            <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
            <remarks>Zip path names are actually in Unix format, and should only contain relative paths.
            This means that any path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid for a file where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String)">
            <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
            <param name="name">The name to test.</param>
            <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
            <remarks>Zip path names are actually in unix format,
            and should only contain relative paths if a path is present.
            This means that the path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream">
             <summary>
             This is a DeflaterOutputStream that writes the files into a zip
             archive one after another.  It has a special method to start a new
             zip entry.  The zip entries contains information about the file name
             size, compressed size, CRC, etc.
             
             It includes support for Stored and Deflated entries.
             This class is not thread safe.
             <br/>
             <br/>Author of the original java version : Jochen Hoenicke
             </summary>
             <example> This sample shows how to create a zip file
             <code>
             using System;
             using System.IO;
             
             using ICCEmbedded.SharpZipLib.Core;
             using ICCEmbedded.SharpZipLib.Zip;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		string[] filenames = Directory.GetFiles(args[0]);
             		byte[] buffer = new byte[4096];
             		
             		using ( ZipOutputStream s = new ZipOutputStream(File.Create(args[1])) ) {
             		
             			s.SetLevel(9); // 0 - store only to 9 - means best compression
             		
             			foreach (string file in filenames) {
             				ZipEntry entry = new ZipEntry(file);
             				s.PutNextEntry(entry);
            
             				using (FileStream fs = File.OpenRead(file)) {
            						StreamUtils.Copy(fs, s, buffer);
             				}
             			}
             		}
             	}
             }	
             </code>
             </example>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Zip output stream, writing a zip archive.
            </summary>
            <param name="baseOutputStream">
            The output stream to which the archive contents are written.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.IsFinished">
            <summary>
            Gets a flag value of true if the central header has been added for this archive; false if it has not been added.
            </summary>
            <remarks>No further entries can be added once this has been done.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.SetComment(System.String)">
            <summary>
            Set the zip file comment.
            </summary>
            <param name="comment">
            The comment text for the entire archive.
            </param>
            <exception name ="ArgumentOutOfRangeException">
            The converted comment is longer than 0xffff bytes.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  The new level will be activated
            immediately.
            </summary>
            <param name="level">The new compression level (1 to 9).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.GetLevel">
            <summary>
            Get the current deflater compression level
            </summary>
            <returns>The current compression level</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.UseZip64">
            <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
            <remarks>Older archivers may not understand Zip64 extensions.
            If backwards compatability is an issue be careful when adding <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Size">entries</see> to an archive.
            Setting this property to off is workable but less desirable as in those circumstances adding a file
            larger then 4GB will fail.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeLong(System.Int64)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.PutNextEntry(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Starts a new Zip entry. It automatically closes the previous
            entry if present.
            All entry elements bar name are optional, but must be correct if present.
            If the compression method is stored and the output is not patchable
            the compression for that entry is automatically changed to deflate level 0
            </summary>
            <param name="entry">
            the entry.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if entry passed is null.
            </exception>
            <exception cref="T:System.IO.IOException">
            if an I/O error occured.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            if stream was finished
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            Too many entries in the Zip file<br/>
            Entry name is too long<br/>
            Finish has already been called<br/>
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.CloseEntry">
            <summary>
            Closes the current entry, updating header and footer information as required
            </summary>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            No entry is active.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the given buffer to the current entry.
            </summary>
            <param name="buffer">The buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">Archive size is invalid</exception>
            <exception cref="T:System.InvalidOperationException">No entry is active.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.Finish">
            <summary>
            Finishes the stream.  This will write the central directory at the
            end of the zip file and flush the stream.
            </summary>
            <remarks>
            This is automatically called when the stream is closed.
            </remarks>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            Comment exceeds the maximum length<br/>
            Entry name exceeds the maximum length
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.entries">
            <summary>
            The entries for the archive.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.crc">
            <summary>
            Used to track the crc of data added to entries.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.curEntry">
            <summary>
            The current entry being added.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.size">
            <summary>
            Used to track the size of data for an entry during writing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.offset">
            <summary>
            Offset to be recorded for each entry in the central header.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.zipComment">
            <summary>
            Comment for the entire archive recorded in central header.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.patchEntryHeader">
            <summary>
            Flag indicating that header patching is required for the current entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.crcPatchPos">
            <summary>
            Position to patch crc
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.sizePatchPos">
            <summary>
            Position to patch size.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipStrings">
            <summary>
            This static class contains functions for encoding and decoding zip file strings
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipStrings.codePage">
            <summary>Code page backing field</summary>
            <remarks>
            The original Zip specification (https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) states
            that file names should only be encoded with IBM Code Page 437 or UTF-8.
            In practice, most zip apps use OEM or system encoding (typically cp437 on Windows).
            Let's be good citizens and default to UTF-8 http://utf8everywhere.org/
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipStrings.AutomaticCodePage">
            Automatically select codepage while opening archive
            see https://github.com/icsharpcode/SharpZipLib/pull/280#issuecomment-433608324
            
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage">
            <summary>
            Encoding used for string conversion. Setting this to 65001 (UTF-8) will
            also set the Language encoding flag to indicate UTF-8 encoded file names.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.SystemDefaultCodePage">
            <summary>
            Attempt to get the operating system default codepage, or failing that, to
            the fallback code page IBM 437.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.UseUnicode">
            <summary>
            Get wether the default codepage is set to UTF-8. Setting this property to false will
            set the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/> to <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.SystemDefaultCodePage"/>
            </summary>
            <remarks>
            /// Get OEM codepage from NetFX, which parses the NLP file with culture info table etc etc.
            But sometimes it yields the special value of 1 which is nicknamed <c>CodePageNoOEM</c> in <see cref="T:System.Text.Encoding"/> sources (might also mean <c>CP_OEMCP</c>, but Encoding puts it so).
            This was observed on Ukranian and Hindu systems.
            Given this value, <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)"/> throws an <see cref="T:System.ArgumentException"/>.
            So replace it with <see cref="F:ICCEmbedded.SharpZipLib.Zip.ZipStrings.FallbackCodePage"/>, (IBM 437 which is the default code page in a default Windows installation console.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[count - 1] converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to a string using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to a string  using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to a string using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipStrings.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array using <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipStrings.CodePage"/>
            </summary>
            <param name="flags">The applicable <see cref="T:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags">general purpose bits flags</see></param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:CQ.IO.Compression.InputBuffer.CopyTo(System.Byte[],System.Int32,System.Int32)">
            Copies length bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            Returns the number of bytes copied, 0 if no byte is available.
        </member>
        <member name="T:CQ.IO.Compression.SR">
            <summary>
            NOTE: this is a hacked in replacement for the SR class
                CQ games don't care about localized exception messages, so we just hacked these in the best we could
            </summary>
        </member>
        <member name="T:P2P.CRegP2PClient">
            <summary>
            注册游戏客户端,当名称为空时其它客户端不可见
            </summary>
        </member>
        <member name="T:P2P.ClientInfo">
            <summary>
            客户端信息
            </summary>
        </member>
        <member name="T:P2P.SRegP2PClient">
            <summary>
            返回注册的客户端列表
            </summary>
        </member>
        <member name="F:P2P.SRegP2PClient.dic">
            <summary>
            当前注册了的客户端列表
            </summary>
        </member>
        <member name="T:P2P.P2PState">
            <summary>
            1.添加 2.删除
            </summary>
        </member>
        <member name="T:P2P.SUpdateP2P">
            <summary>
            更新其它P2P客户端
            </summary>
        </member>
        <member name="T:P2P.P2PMsg">
            <summary>
            P2P客户端相互传递消息
            </summary>
        </member>
        <member name="T:P2P.P2P_ClientServerInfo">
            <summary>
            向其他客户端通知自己的开放端口,ip
            </summary>
        </member>
        <member name="T:P2P.P2P_ClientId">
            <summary>
            向其他客户端通知自己的id
            </summary>
        </member>
        <member name="M:PENet.CqClient.Connect(System.String,System.Int32)">
            <summary>
            Launch Client
            </summary>
        </member>
        <member name="M:PENet.PESession.PackLenInfo(System.Byte[])">
            <summary>
            Add length info to package
            </summary>
        </member>
        <member name="M:PENet.PESession.SendBytes(System.Byte[])">
            <summary>
            Send binary data
            </summary>
        </member>
        <member name="M:PENet.PESession.Clear">
            <summary>
            Release Resource
            </summary>
        </member>
        <member name="E:PENet.PESession.OnConnected">
            <summary>
            Connect network
            </summary>
        </member>
        <member name="E:PENet.PESession.OnReciveBytes">
            <summary>
            Receive network message
            </summary>
        </member>
        <member name="E:PENet.PESession.OnDisConnected">
            <summary>
            Disconnect network
            </summary>
        </member>
        <member name="T:RingBuffer">
            <summary>
            环形队列
            生产者消费者模型
            一个高效率可复用的缓存区
            异步数据接收有可能收到的数据不是一个完整包，或者接收到的数据超过一个包的大小，
            因此我们需要把接收的数据进行缓存。
            异步发送我们也需要把每个发送的包加入到一个队列，然后通过队列逐个发送出去，
            如果每个都实时发送，有可能造成上一个数据包未发送完成，
            这时再调用SendAsync会抛出异常，提示SocketAsyncEventArgs正在进行异步操作，
            因此我们需要建立接收缓存和发送缓存。
            </summary>
        </member>
        <member name="M:RingBuffer.GetReserveCount">
            <summary>
            获得剩余可复用字节数
            </summary>
            <returns></returns>
        </member>
        <member name="M:RingBuffer.Send(System.IO.Stream)">
            <summary>
            将缓冲数据通过网络数据流发送出去
            </summary>
        </member>
        <member name="M:RingBuffer.Receive(System.IO.Stream)">
            <summary>
            从网络数据流接收数据到缓冲
            如果接收到0,证明已经断开
            </summary>
        </member>
        <member name="M:RingBuffer.LoopInput(System.Byte[])">
            <summary>
            由线程调用
            循环将数据写入缓冲
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:RingBuffer.LoopOutput(System.Int32)">
            <summary>
            由线程调用
            循环读取缓冲中的数据
            </summary>
        </member>
        <member name="M:RingBuffer.InputData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将数据写入缓冲
            写入空间不够返回false
            </summary>
        </member>
        <member name="M:RingBuffer.OutputData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将缓冲数据导出
            </summary>
        </member>
        <member name="T:SerializeTypeUtil">
            <summary>
            定义对指定类型的序列化方式(1.字段(默认) 2.属性 )<para/>
            1.当有强制指定类型的序列化样式时使用指定方式处理<para/>
            2.当有MarkSerializeByPropertyAttribute特性修饰时,用属性来序列化<para/>
            3.否则按序列化
            </summary>
        </member>
        <member name="M:SerializeTypeUtil.RegType(System.Type,System.String,CqCore.SerializeTypeStyle)">
            <summary>
            强制指定类型的序列化样式和名称
            </summary>
        </member>
        <member name="M:SerializeTypeUtil.GetStyle(System.Type,System.Boolean)">
            <summary>
            获取类型的序列化样式<para/>
            1.当有强制指定类型的序列化样式时使用指定方式处理<para/>
            2.当有MarkSerializeByPropertyAttribute特性修饰时,用属性来序列化<para/>
            3.否则按序列化
            </summary>
        </member>
        <member name="T:CSV">
            <summary>
            CSV数据格式的序列化
            </summary>
        </member>
        <member name="M:CSV.Deserialize(System.String)">
            <summary>
            序列化表格数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSV.TryDeserialize``1(System.String)">
            <summary>
            用确定的行数据对象类型来序列化表格数据
            </summary>
            <typeparam name="T"></typeparam>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="F:CqSerialize.Serializer.serializeDic">
            <summary>
            已经序列化过的单位
            </summary>
        </member>
        <member name="F:CqSerialize.Serializer.currentDepth">
            <summary>
            当前深度
            </summary>
        </member>
        <member name="M:CqSerialize.Serializer.IsRecordingType(System.Type)">
            <summary>
            当是class修饰的非基础数据类型时,该类型的实例可以被重复引用.<para/>
            所以当开启排除递归后,在序列化这个对象时需要记录hashId
            </summary>
        </member>
        <member name="M:CqSerialize.Serializer.SerializeValue(System.Object,System.Type,System.Boolean)">
            <summary>
            序列化任意一个对象
            </summary>
            <param name="obj">准备序列化的对象</param>
            <param name="inputType">输入类型</param>
            <param name="inExpression">是否是表达式中的值,用于控制输出格式</param>
        </member>
        <member name="M:CqSerialize.Serialize(System.Object,CqCore.SerializeFormat)">
            <summary>
            序列化
            </summary>
            <param name="obj">序列化对象</param>
            <param name="format">序列化样式</param>
            <returns>序列化后的文本内容</returns>
        </member>
        <member name="M:CqSerialize.Parse``1(System.String,CqCore.ParserFormat)">
            <summary>
            反序列化
            </summary>
        </member>
        <member name="M:CqSerialize.Parse(System.String,System.Type,CqCore.ParserFormat)">
            <summary>
            反序列化
            </summary>
        </member>
        <member name="T:CqSerialize.Parser">
            <summary>
            按类型解析
            1.基本数据类型
            2.枚举
            3.数组
            4.字典
            5.自定义类
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseValue(System.Type,System.Object@)">
            <summary>
            输出类型
            1.自定义类型
            2.整形数字为int
            3.浮点数字为float
            4.字符串为string
            5.布尔为bool
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseType(System.Type,System.Object@)">
            <summary>
            解析类型名,包含泛型,以及泛型嵌套类型
            1.  List&lt;T&gt;
            2. T() 数组
            3.  Dictionary&lt;Tkey,Tvalue&gt;
            4. T
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseObject(System.Type,System.Object@)">
            <summary>
            读取字段成员
            解析对象(Type){ var=value;...}
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseList(System.Type,System.Object@)">
            <summary>
            解析List(listType&lt;itemType&gt;)[ value,...]
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseArray(System.Type,System.Object@)">
            <summary>
            解析数组 T()[ value,...]
            </summary>
        </member>
        <member name="M:CqSerialize.Parser.TryParseDictionary(System.Type,System.Object@)">
            <summary>
            解析字典(dicType&lt;keyType,valueType&gt;)
            { value:value,value:value...} -->
            </summary>
        </member>
        <member name="T:ICqSerialize">
            <summary>
            对象序列化和反序列化后的回调接口
            </summary>
        </member>
        <member name="T:StringUtil">
            <summary>
            Title: String Utility Description: Collection of string handling utilities
            @author     Andrew C. Oliver
            @author     Sergei Kozello (sergeikozello at mail.ru)
            @author     Toshiaki Kamoshida (kamoshida.toshiaki at future dot co dot jp)
            @since      May 10, 2002
            @version    1.0
            </summary>
            <summary>
            编码函数
            </summary>
        </member>
        <member name="M:StringUtil.GetFromUnicodeLE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Given a byte array of 16-bit unicode characters in Little Endian
            Format (most important byte last), return a Java String representation
            of it.
            { 0x16, 0x00 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <param name="offset">the initial offset into the
            byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character</param>
            <param name="len">the Length of the string</param>
            <returns>the converted string</returns>                              
        </member>
        <member name="M:StringUtil.GetFromUnicodeLE(System.Byte[])">
             <summary>
             Given a byte array of 16-bit unicode characters in little endian
             Format (most important byte last), return a Java String representation
             of it.
            { 0x16, 0x00 } -0x16
             </summary>
             <param name="str">the byte array to be converted</param>
             <returns>the converted string</returns>  
        </member>
        <member name="M:StringUtil.GetToUnicodeLE(System.String)">
             Convert String to 16-bit unicode characters in little endian format
            
             @param string the string
             @return the byte array of 16-bit unicode characters
        </member>
        <member name="M:StringUtil.GetFromUnicodeBE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Given a byte array of 16-bit unicode characters in big endian
            Format (most important byte first), return a Java String representation
            of it.
             { 0x00, 0x16 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <param name="offset">the initial offset into the
            byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character</param>
            <param name="len">the Length of the string</param>
            <returns> the converted string</returns>
        </member>
        <member name="M:StringUtil.GetFromUnicodeBE(System.Byte[])">
            <summary>
            Given a byte array of 16-bit unicode characters in big endian
            Format (most important byte first), return a Java String representation
            of it.
            { 0x00, 0x16 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <returns>the converted string</returns>      
        </member>
        <member name="M:StringUtil.GetFromCompressedUnicode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 8 bit data (in IsO-8859-1 codepage) into a (unicode) Java
            String and return.
            (In Excel terms, read compressed 8 bit unicode as a string)
            </summary>
            <param name="str">byte array to read</param>
            <param name="offset">offset to read byte array</param>
            <param name="len">Length to read byte array</param>
            <returns>generated String instance by reading byte array</returns>
        </member>
        <member name="M:StringUtil.PutCompressedUnicode(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode (java) string, and returns it as 8 bit data (in IsO-8859-1
            codepage).
            (In Excel terms, write compressed 8 bit unicode)
            </summary>
            <param name="input">the String containing the data to be written</param>
            <param name="output">the byte array to which the data Is to be written</param>
            <param name="offset">an offset into the byte arrat at which the data Is start when written</param>
        </member>
        <member name="M:StringUtil.PutUnicodeLE(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode string, and returns it as little endian (most
            important byte last) bytes in the supplied byte array.
            (In Excel terms, write uncompressed unicode)
            </summary>
            <param name="input">the String containing the unicode data to be written</param>
            <param name="output">the byte array to hold the uncompressed unicode, should be twice the Length of the String</param>
            <param name="offset">the offset to start writing into the byte array</param>
        </member>
        <member name="M:StringUtil.PutUnicodeBE(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode string, and returns it as big endian (most
            important byte first) bytes in the supplied byte array.
            (In Excel terms, write uncompressed unicode)
            </summary>
            <param name="input">the String containing the unicode data to be written</param>
            <param name="output">the byte array to hold the uncompressed unicode, should be twice the Length of the String.</param>
            <param name="offset">the offset to start writing into the byte array</param>
        </member>
        <member name="M:StringUtil.GetPreferredEncoding">
            <summary>
            Gets the preferred encoding.
            </summary>
            <returns>the encoding we want to use, currently hardcoded to IsO-8859-1</returns>
        </member>
        <member name="M:StringUtil.HasMultibyte(System.String)">
            <summary>
            check the parameter Has multibyte character
            </summary>
            <param name="value"> string to check</param>
            <returns>
            	<c>true</c> if Has at least one multibyte character; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:StringUtil.GetEncodedSize(System.String)">
            <summary>
            Gets the number of bytes that would be written by WriteUnicodeString(LittleEndianOutput, String)
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:StringUtil.IsUnicodeString(System.String)">
             <summary>
             Checks to see if a given String needs to be represented as Unicode
             </summary>
             <param name="value">The value.</param>
             <returns>
             	<c>true</c> if string needs Unicode to be represented.; otherwise, <c>false</c>.
             </returns>
            <remarks>Tony Qu change the logic</remarks>
        </member>
        <member name="M:StringUtil.ToHexString(System.String)">
            <summary> 
            Encodes non-US-ASCII characters in a string, good for encoding file names for download 
            http://www.acriticsreview.com/List.aspx?listid=42
            </summary> 
            <param name="s"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.ToHexString(System.Char)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.ToHexString(System.Int16)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.ToHexString(System.Int32)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.ToHexString(System.Int64)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.NeedToEncode(System.Char)">
            <summary> 
            Determines if the character needs to be encoded. 
            http://www.acriticsreview.com/List.aspx?listid=42
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:StringUtil.mapMsCodepointString(System.String)">
             Some strings may contain encoded characters of the unicode private use area.
             Currently the characters of the symbol fonts are mapped to the corresponding
             characters in the normal unicode range. 
            
             @param string the original string 
             @return the string with mapped characters
             
             @see <a href="http://www.alanwood.net/unicode/private_use_area.html#symbol">Private Use Area (symbol)</a>
             @see <a href="http://www.alanwood.net/demos/symbol.html">Symbol font - Unicode alternatives for Greek and special characters in HTML</a>
        </member>
        <member name="F:StringUtil.MIN_HIGH_SURROGATE">
             The minimum value of a
             <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
             Unicode high-surrogate code unit</a>
             in the UTF-16 encoding, constant {@code '\u005CuD800'}.
             A high-surrogate is also known as a <i>leading-surrogate</i>.
            
             @since 1.5
        </member>
        <member name="F:StringUtil.MAX_HIGH_SURROGATE">
             The maximum value of a
             <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
             Unicode high-surrogate code unit</a>
             in the UTF-16 encoding, constant {@code '\u005CuDBFF'}.
             A high-surrogate is also known as a <i>leading-surrogate</i>.
            
             @since 1.5
        </member>
        <member name="F:StringUtil.MIN_LOW_SURROGATE">
             The minimum value of a
             <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
             Unicode low-surrogate code unit</a>
             in the UTF-16 encoding, constant {@code '\u005CuDC00'}.
             A low-surrogate is also known as a <i>trailing-surrogate</i>.
            
             @since 1.5
        </member>
        <member name="F:StringUtil.MAX_LOW_SURROGATE">
             The maximum value of a
             <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
             Unicode low-surrogate code unit</a>
             in the UTF-16 encoding, constant {@code '\u005CuDFFF'}.
             A low-surrogate is also known as a <i>trailing-surrogate</i>.
            
             @since 1.5
        </member>
        <member name="M:StringUtil.toCodePoint(System.Char,System.Char)">
             Converts the specified surrogate pair to its supplementary code
             point value. This method does not validate the specified
             surrogate pair. The caller must validate it using {@link
             #isSurrogatePair(char, char) isSurrogatePair} if necessary.
            
             @param  high the high-surrogate code unit
             @param  low the low-surrogate code unit
             @return the supplementary code point composed from the
                     specified surrogate pair.
             @since  1.5
        </member>
        <member name="M:StringUtil.CharCount(System.Int32)">
             Determines the number of {@code char} values needed to
             represent the specified character (Unicode code point). If the
             specified character is equal to or greater than 0x10000, then
             the method returns 2. Otherwise, the method returns 1.
            
             This method doesn't validate the specified character to be a
             valid Unicode code point. The caller must validate the
             character value using {@link #isValidCodePoint(int) isValidCodePoint}
             if necessary.
            
             @param   codePoint the character (Unicode code point) to be tested.
             @return  2 if the character is a valid supplementary character; 1 otherwise.
             @see     Character#isSupplementaryCodePoint(int)
             @since   1.5
        </member>
        <member name="M:StringUtil.SubstringEx(System.String,System.Int32,System.Int32)">
            <summary>
            返回从起始偏移startIndex 从末尾偏移endIndexR的一段子串
            </summary>
        </member>
        <member name="M:StringUtil.MatchReplace(System.String,System.String,System.Func{System.Int32,System.Text.RegularExpressions.Match,System.String})">
            <summary>
            查找pattern捕获替换为函数OnMatch调用的返回值
            </summary>
        </member>
        <member name="M:StringUtil.ReplaceSubStr(System.String,System.String,System.String,System.Func{System.String,System.String})">
            <summary>
            通过func替换以start起始,以end结尾的中间内容子串,返回结果
            替换多次
            </summary>
        </member>
        <member name="M:StringUtil.ReplaceSubStrByBool(System.String,System.Boolean,System.String,System.String,System.String)">
            <summary>
            通过bool 值,确定保留start-middle 还是 middle-end, 返回结果
            true:start-middle
            false:middle-end
            </summary>
        </member>
        <member name="M:StringUtil.FlagChoose(System.String,System.Int32)">
            <summary>
            在content中找寻{*}段落,并由flag选出对应的段落,按位选取
            通过{}定义一系列段落,由flag来确定包含哪些段落(flag:1,2,4,8)
            例:_FlagChoose("x{a}{b}{c}y",3)结果为"xaby"
            </summary>
        </member>
        <member name="M:StringUtil.FlagChooseOne(System.String,System.Int32)">
            <summary>
            在content中找寻{*}段落,并由flag选出对应的段落,按位选取
            通过{}定义一系列段落,由flag来确定包含哪些段落(flag:1,2,3,4)
            例:_FlagChooseOne("x{a}{b}{c}y",3)结果为"xcy"  
            </summary>
        </member>
        <member name="M:StringUtil.NumberOfLines(System.String)">
            <summary>
            返回行数
            </summary>
        </member>
        <member name="M:StringUtil.FormatBytes(System.Int64,System.Boolean)">
            <summary>
            字节单位转文本显示,常用于表示文件大小,内存大小,硬盘大小<para/>
            </summary>
            <param name="size">字节大小</param>
            <param name="hasSymbol">固定带上正负符号</param>
            <returns></returns>
        </member>
        <member name="M:StringUtil.IndexOfAll(System.String,System.String)">
            <summary>
            查找全部
            </summary>
        </member>
        <member name="M:StringUtil.ReplaceAll(System.String,System.String,System.String)">
            <summary>
            替换全部
            </summary>
        </member>
        <member name="M:StringUtil.Split(System.String,System.String)">
            <summary>
            字符串分隔
            </summary>
        </member>
        <member name="M:StringUtil.FormatNumber(System.String,System.Int32,System.String@)">
            <summary>
            转百分数显示
            </summary>
        </member>
        <member name="M:StringUtil.FormatNumberPercent(System.String,System.Int32)">
            <summary>
            转百分数显示
            </summary>
        </member>
        <member name="M:StringUtil.SplitWithDepth(System.String,System.Char)">
            <summary>
            按深度拆分字符串
            拆分字符串,对[]内容整体视为下一级
            </summary>
        </member>
        <member name="M:StringUtil.GetEnumComplexString``1(``0)">
            <summary>
            得到复合枚举值 的多项合成表达式
            例:Enum Et{A=1,B=2}
            Et t=(Et)3;
            GetEnumComplexString(t)  => "A|B"
            </summary>
        </member>
        <member name="M:StringUtil.SplitLine(System.String)">
            <summary>
            按换行符\r\n拆分成字符串数组
            </summary>
        </member>
        <member name="M:StringUtil.EnumNameToValue``1(System.String)">
            <summary>
            枚举项名字转值
            </summary>
        </member>
        <member name="M:StringUtil.MidExpression(System.String)">
            <summary>
            四则运算+-*/(
            </summary>
        </member>
        <member name="M:StringUtil.Repeat(System.Char,System.Int32)">
            <summary>
            获取多个相同字符组成的字符串
            </summary>
        </member>
        <member name="P:StringUtil.GB2312">
            <summary>
            安卓手机上不支持调用国标编码
            </summary>
        </member>
        <member name="M:StringUtil.GetChineseCharCount(System.String)">
            <summary>
            中文字符数
            </summary>
        </member>
        <member name="M:StringUtil.Md5Sum(System.String)">
            <summary>
            返回大写字母和数字的组合
            </summary>
        </member>
        <member name="M:StringUtil.UrlEncode(System.String)">
            <summary>
            中文网络地址转码
            </summary>
        </member>
        <member name="M:StringUtil.TransferEncoding(System.Text.Encoding,System.Text.Encoding,System.String)">
            <summary>
            字符串编码转换
            </summary>
            <param name="srcEncoding">原编码</param>
            <param name="dstEncoding">目标编码</param>
            <param name="srcStr">原字符串</param>
            <returns>字符串</returns>
        </member>
        <member name="T:ObjectPool`1">
            <summary>
            对象池
            </summary>
        </member>
        <member name="M:System.EaseFun.ConvertToOut(System.Func{System.Double,System.Double})">
            <summary>
            基于0~1的缓动转缓出
            </summary>
        </member>
        <member name="M:System.EaseFun.ConvertToInOut(System.Func{System.Double,System.Double})">
            <summary>
            基于0~1的缓动转缓入缓出
            </summary>
        </member>
        <member name="M:System.EaseFun.LinearEase(System.Double)">
            <summary>
            直线
            </summary>
        </member>
        <member name="M:System.EaseFun.QuadraticEase(System.Double)">
            <summary>
            二次
            </summary>
        </member>
        <member name="M:System.EaseFun.CubicEase(System.Double)">
            <summary>
            三次
            </summary>
        </member>
        <member name="M:System.EaseFun.QuarticEase(System.Double)">
            <summary>
            四次
            </summary>
        </member>
        <member name="M:System.EaseFun.QuinticEase(System.Double)">
            <summary>
            五次
            </summary>
        </member>
        <member name="M:System.EaseFun.ExpoEase(System.Double)">
            <summary>
            指数
            </summary>
        </member>
        <member name="M:System.EaseFun.BackEase(System.Double)">
            <summary>
            返回
            </summary>
        </member>
        <member name="M:System.EaseFun.SineEase(System.Double)">
            <summary>
            正弦
            </summary>
        </member>
        <member name="M:System.EaseFun.CircleEase(System.Double)">
            <summary>
            圆弧
            </summary>
        </member>
        <member name="M:System.EaseFun.ElasticEase(System.Double)">
            <summary>
            弹性振荡
            </summary>
        </member>
        <member name="M:System.EaseFun.BounceEase(System.Double)">
            <summary>
            反弹
            </summary>
        </member>
        <member name="M:System.ArrayUtil.RoundCopy``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
            <summary>
            循环拷贝
            </summary>
        </member>
        <member name="M:System.ArrayUtil.SplitByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将一个数组拆成另外一个数组
            </summary>
            <param name="originbyte">原始数组，被拆分的数组</param>
            <param name="startIndex">从原始数组第几个元素开始</param>
            <param name="endIndex">从原始数组第几个元素结束</param>
            <returns></returns>
        </member>
        <member name="M:System.Diagnostics.StackTraceUtil.GetStack">
            <summary>
            获得当前堆栈信息
            </summary>
        </member>
        <member name="M:System.IO.BinaryReaderUtil.ReadToEnd(System.IO.BinaryReader,System.Int64,System.Single@)">
            <summary>
            让二进制流读取能像SteamReader一样方便地ReadToEnd
            </summary>
        </member>
        <member name="M:System.IO.BinaryReaderUtil.ReadToEnd(System.IO.BinaryReader)">
            <summary>
            让二进制流读取能像SteamReader一样方便地ReadToEnd
            </summary>
        </member>
        <member name="T:System.IO.FolderUtil">
            <summary>
            文件夹扩展
            </summary>
        </member>
        <member name="M:System.IO.FolderUtil.Delete(System.String,System.Boolean)">
            <summary>
            递归删除文件夹
            </summary>
        </member>
        <member name="M:System.IO.FolderUtil.PreorderTraversal(System.String,System.Action{System.String},System.Action{System.String})">
            <summary>
            遍历文件夹下所有文件(包含子文件夹下的文件)
            </summary>
        </member>
        <member name="M:System.ConvertUtil.ChangeType(System.Object,System.Type)">
            <summary>
            类型转换
            </summary>
        </member>
        <member name="M:System.ConvertUtil.ConvertType(System.Object,System.Type)">
            <summary>
            主要操作基本类型转换,比如int 转uint,float 转double之类
            也可以支持自定义类型,需要实现System.IConvertible接口
            </summary>
        </member>
        <member name="M:System.ConvertUtil.FromType``2(``1)">
            <summary>
            从类型
            </summary>
        </member>
        <member name="M:System.SystemUtil.ToBase64(System.Byte[])">
            <summary>
            将 8 位无符号整数的数组转换为其用 Base64 数字编码的等效字符串表示形式
            </summary>
        </member>
        <member name="M:System.SystemUtil.ToBase64(System.String)">
            <summary>
            将指定的字符串（它将二进制数据编码为 Base64 数字）转换为等效的 8 位无符号整数数组
            </summary>
        </member>
        <member name="T:System.Threading.ThreadUtil">
            <summary>
            切换线程调用的API
            </summary>
        </member>
        <member name="M:System.Threading.ThreadUtil.DelayCall(System.Single,System.Action,CqCore.ICancelHandle)">
            <summary>
            开启线程异步延迟执行方法
            </summary>
        </member>
        <member name="M:System.Threading.ThreadUtil.DelayCall(System.Int32,System.Action,CqCore.ICancelHandle)">
            <summary>
            开启线程异步延迟执行方法
            </summary>
        </member>
        <member name="M:System.Threading.ThreadUtil.ThreadCall(System.Action,CqCore.ICancelHandle)">
            <summary>
            开启线程异步执行方法
            </summary>
        </member>
        <member name="M:System.Threading.ThreadUtil.PoolCall(System.Action,CqCore.ICancelHandle)">
            <summary>
            由线程池分配线程异步执行一些短时间的,有可能是高频的任务
            </summary>
        </member>
        <member name="M:System.Threading.ThreadUtil.PoolCall(System.Action,System.Action{System.Boolean},CqCore.ICancelHandle)">
            <summary>
            开启线程异步调用,完成回调OnResult
            </summary>
        </member>
        <member name="T:FileOpr">
            <summary>
            文件操作类
            </summary>
        </member>
        <member name="M:FileOpr.RunByRelativePath(System.String,System.String)">
            <summary>
            执行程序
            </summary>
        </member>
        <member name="M:FileOpr.IsOccupy(System.String)">
            <summary>
            文件是否被占用
            </summary>
        </member>
        <member name="M:FileOpr.Exists(System.String)">
            <summary>
            确定指定的文件是否存在。
            </summary>
        </member>
        <member name="M:FileOpr.Copy(System.String,System.String,System.Boolean)">
            <summary>
            复制
            </summary>
        </member>
        <member name="M:FileOpr.CopyFolder(System.String,System.String,System.Boolean)">
            <summary>
            复制文件夹到目标文件夹内
            </summary>
        </member>
        <member name="M:FileOpr.ReName(System.String,System.String)">
            <summary>
            改文件名
            </summary>
        </member>
        <member name="M:FileOpr.DeleteFile(System.String)">
            <summary>
            删除文件
            </summary>
        </member>
        <member name="M:FileOpr.DeleteFolder(System.String)">
            <summary>
            删除文件夹，如果有子文件夹和文件一并删除
            </summary>
        </member>
        <member name="M:FileOpr.PreorderTraversal(System.String,System.Action{System.String},System.Action{System.String})">
            <summary>
            遍历文件夹下所有文件(包含子文件夹下的文件)
            </summary>
        </member>
        <member name="M:FileOpr.SaveFile(System.String,System.Byte[])">
            <summary>
            写文件, 当文件不存在时创建
            文件存在时覆盖
            </summary>
        </member>
        <member name="M:FileOpr.SaveFile(System.String,System.String,System.Boolean)">
            <summary>
            默认utf8无bom保存文件
            </summary>
        </member>
        <member name="M:FileOpr.SaveFileX(System.String,System.String,System.Boolean,FileType)">
            <summary>
            写文件, 当文件不存在时创建
            over:true 文件存在时覆盖
            over:false (文件存在时不执行)
            </summary>
        </member>
        <member name="M:FileOpr.SaveFile(System.String,System.Byte[],System.Boolean)">
            <summary>
            写文件, 当文件不存在时创建
            over:true 文件存在时覆盖
            over:false (文件存在时不执行)
            </summary>
        </member>
        <member name="M:FileOpr.ReadFile(System.String,System.Text.Encoding)">
            <summary>
            读文件(默认UTF8)
            </summary>
            <param name="path">文件路径</param>
            <param name="encoding">编码</param>
            <returns></returns>
        </member>
        <member name="M:FileOpr.SaveFile_UTF8(System.String,System.String)">
            <summary>
            无bom保存
            </summary>
        </member>
        <member name="M:FileOpr.SaveObject(System.String,System.Object)">
            <summary>
            将对象用Torsion序列化后,用Encoding.UTF8保存
            </summary>
        </member>
        <member name="M:FileOpr.ReadObject``1(System.String)">
            <summary>
            用Encoding.UTF8格式反序列化文件后输出对象
            </summary>
        </member>
        <member name="M:FileOpr.GetMD5Hash(System.String)">
            <summary>  
            获取文件的MD5码  
            </summary>  
            <param name="fileName">传入的文件名（含路径及后缀名）</param>  
            <returns></returns>  
        </member>
        <member name="M:FileOpr.GetChildFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            获取文件夹下子文件
            </summary>
        </member>
        <member name="M:FileOpr.GetParentFolder(System.String)">
            <summary>
            上一级目录
            </summary>
        </member>
        <member name="M:FileOpr.GetParent(System.String)">
            <summary>
            上一级目录
            </summary>
        </member>
        <member name="M:FileOpr.GetFileName(System.String)">
            <summary>
            返回指定路径字符串的文件名和扩展名。
            </summary>
        </member>
        <member name="M:FileOpr.GetLastWriteTime(System.String)">
            <summary>
            获取文件最后修改时间
            </summary>
        </member>
        <member name="M:FileOpr.GetFileSize(System.String)">
            <summary>
            获取文件/文件夹大小
            </summary>
        </member>
        <member name="M:FileOpr.GetNameByExtension(System.String)">
            <summary>
            返回指定的路径字符串的扩展名
            </summary>
        </member>
        <member name="M:FileOpr.GetNameByShort(System.String)">
            <summary>
            返回不具有扩展名的指定路径字符串的文件名。
            </summary>
        </member>
        <member name="M:FileOpr.ToAbsolutePath(System.String)">
            <summary>
            通过相对路径获取绝对路径，路径以\分隔
            </summary>
        </member>
        <member name="M:FileOpr.ToRelativePath(System.String,System.String)">
            <summary>
            通过绝对路径获取相对路径(路径以分隔)
            </summary>
        </member>
        <member name="M:FileOpr.IsLinkPath(System.String)">
            <summary>
            是一个链接目录
            </summary>
        </member>
        <member name="M:FileOpr.IsFilePath(System.String)">
            <summary>
            是一个正确的文件路径
            </summary>
        </member>
        <member name="M:FileOpr.IsFolderPath(System.String)">
            <summary>
            是一个正确的文件夹路径
            </summary>
        </member>
        <member name="M:FileOpr.SearchFilePath(System.String)">
            <summary>
            查找文件
            </summary>
        </member>
        <member name="M:FileOpr.CurrentVersion">
            <summary>
            获得当前应用软件的版本
            </summary>
        </member>
        <member name="M:FileOpr.CurrentApplicationDirectory">
            <summary>
            获得当前应用程序的根目录
            </summary>
        </member>
        <member name="M:FileOpr.UnZipFile(System.String,System.String)">
            <summary>
            解压
            </summary>
        </member>
        <member name="M:FileOpr.CreateZipFile(System.String,System.String[])">
            <summary>
            压缩
            </summary>
        </member>
        <member name="M:FileOpr.GetFileEncoding(System.String)">
            <summary> 
            给定文件的路径，读取文件的二进制数据，判断文件的编码类型 
            </summary> 
            <param name="file">文件路径</param> 
            <returns>文件的编码类型</returns> 
        </member>
        <member name="M:FileOpr.GetType(System.IO.FileStream)">
            <summary> 
            通过给定的文件流，判断文件的编码类型 
            </summary> 
            <param name="fs">文件流</param> 
            <returns>文件的编码类型</returns> 
        </member>
        <member name="M:FileOpr.IsUTF8Bytes(System.Byte[])">
            <summary> 
            判断是否是不带 BOM 的 UTF8 格式 
            </summary> 
            <param name="data"></param> 
            <returns></returns> 
        </member>
        <member name="M:FileOpr.DownloadDataAsync(System.String,System.Action{System.Byte[]})">
            <summary>
            以 System.Byte 数组形式下载指定的资源。此方法不会阻止调用线程。
            </summary>
        </member>
        <member name="M:FileOpr.DownloadFileAsync(System.String,System.Action,System.Action{System.Int64,System.Int64},System.String)">
            <summary>
            将具有指定 URI 的资源下载到本地文件。此方法不会阻止调用线程。
            </summary>
        </member>
        <member name="T:WatcherFile">
            <summary>
            文件监视类
            FileSystemWatcher系统的文件改变有BUG,会由一次文件操作产生多个Changed事件
            </summary>
        </member>
        <member name="P:WatcherFile.EnableChanged">
            <summary>
            可以收到文件变化的回调
            </summary>
        </member>
        <member name="T:FtpOpr">
            <summary>
            通过ftp操作上传或者下载文件
            </summary>
        </member>
        <member name="M:FtpOpr.#ctor(System.String,System.String,System.String)">
            <summary>
            通过ftp操作上传或者下载文件
            </summary>
        </member>
        <member name="M:FtpOpr.DownloadFileAsync(System.String,System.String,System.Action{System.Boolean},System.Action{System.Int64,System.Int64})">
            <summary>
            异步下载文件
            </summary>
        </member>
        <member name="M:FtpOpr.GetFileSize(System.String)">
            <summary>
            获取指定文件大小
            </summary>
        </member>
        <member name="M:FtpOpr.UploadFileAsync(System.String,System.String)">
            <summary>
            异步上传文件
            不使用缓冲区，外部能同时进行多个异步调用
            </summary>
        </member>
        <member name="M:FtpOpr.MakeDir(System.String)">
            <summary>
            创建文件夹
            </summary>
        </member>
        <member name="M:FtpOpr.GetFileModify(System.String)">
            <summary>
            返回文件最后修改时间
            </summary>
        </member>
        <member name="M:PacketData.StructToBytes(System.Object)">
            <summary>
            c#自带结构体转字节数组
            自定义类型需要加上偏移标签和顺序.
            </summary>
        </member>
        <member name="M:PacketData.BytesToStruct(System.Byte[],System.Type)">
            <summary>
            c#自带字节数组转结构体
            自定义类型需要加上偏移标签和顺序.
            </summary>
        </member>
        <member name="T:ParserCore.CharParser">
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器-解析关键字
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            词法分析器
            </summary>
            <summary>
            字符解析器
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseChar(System.Object@)">
            <summary>
            解析一个字符(规则:以'开头中间包含一个字符,以'结尾 ) \"例外
            \不作转译
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseCommentLine(System.Object@)">
            <summary>
            解析一行注释(规则:以//开头中间包含任意字符,行结尾或者文件末尾)
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseKeyword(System.Object@)">
            <summary>
            解析True
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseComment(System.Object@)">
            <summary>
            解析一段注释(规则:以/*开头中间包含任意字符,以*/结尾)
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseSign(System.Object@)">
            <summary>
            解析一个符号
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseVariable(System.Object@)">
            <summary>
            解析一个变量名 (规则:以字母或者_开头,中间可以包含字母数字和_和`和.和+)
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseString(System.Object@)">
            <summary>
            解析一个字符串(规则:以"开头中间包含任意字符,以"结尾 ) \"例外
            \不作转译
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseNumber(System.Object@)">
            <summary>
            解析一个数字 (如:-1.501f ) 输出类型 int float<para/>
            已支持科学计数法格式(-1.3e-2)
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseLogic(FuncOut{System.Object,System.Boolean},System.Object@)">
            <summary>
            解析主体逻辑
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.TryParseConstStr(System.String)">
            <summary>
            解析一个常量字符串
            </summary>
        </member>
        <member name="M:ParserCore.CharParser.Parse">
            <summary>
            解析字符,生成符号,数字,名字,注释,字符串列表
            </summary>
        </member>
        <member name="T:ParserCore.Parsing">
            <summary>
            语法分析器
            </summary>
        </member>
        <member name="T:ParserCore.TokenParser">
            <summary>
            标记解析器
            </summary>
        </member>
        <member name="M:ParserCore.TokenParser.TryParseLogic(FuncOut{System.Type,System.Object,System.Boolean},System.Type,System.Object@)">
            <summary>
            拿list进行解析func解析,解析成功时执行callBack 传入解析结果,返回解析成功还是失败
            解析步骤 1.判断匹配 (不匹配时回溯)2.捕获 3.退出
            </summary>
        </member>
        <member name="M:ParserCore.TokenParser.TryParseLogic(FuncOut{System.Object,System.Boolean},System.Object@)">
            <summary>
            拿list进行解析func解析,解析成功时执行callBack 传入解析结果,返回解析成功还是失败
            解析步骤 1.判断匹配 (不匹配时回溯)2.捕获 3.退出
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.SEMICOLON">
            <summary>
            分号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.LEFT_BRACE">
            <summary>
            左大括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.RIGHT_BRACE">
            <summary>
            右大括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.LEFT_BRACKET">
            <summary>
            左中括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.RIGHT_BRACKET">
            <summary>
            右中括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.LEFT_PARENTHESIS">
            <summary>
            左小括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.RIGHT_PARENTHESIS">
            <summary>
            右小括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.LEFT_ANGLE">
            <summary>
            左尖括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.RIGHT_ANGLE">
            <summary>
            右尖括号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.EQUAL">
            <summary>
            等号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.COLON">
            <summary>
            冒号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.PERCENT">
            <summary>
            百分号
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.BACKSLASH">
            <summary>
            反斜杠 
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.DOT">
            <summary>
            点
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.COMMENT">
            <summary>
            注释
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.NUMBER">
            <summary>
            "数字和小数点和负号组成";
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.STRING">
            <summary>
            双引号包含的字符串
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.VARIABLE">
            <summary>
            "变量名";//由英文字母开头,数字、26个大小写英文字母或者下划线或者小数点,组成的变量名
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.UNKNOWN">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.KEYWORD">
            <summary>
            关键字<para/>
            null,true,false
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.END">
            <summary>
            文件末尾
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.IGNORE">
            <summary>
            忽略的字符
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.CHAR">
            <summary>
            字符
            </summary>
        </member>
        <member name="F:ParserCore.TokenType.COMMA">
            <summary>
            逗号
            </summary>
        </member>
        <member name="T:ParserCore.BaseParser`1">
            <summary>
            用于 深度优先解析 的数据结构
            支持 匹配 回溯
            </summary>
        </member>
        <member name="M:ParserCore.BaseParser`1.Next">
            <summary>
            返回true,表示到结尾了
            </summary>
        </member>
        <member name="M:ParserCore.BaseParser`1.Back">
            <summary>
            解析失败时回溯
            </summary>
        </member>
        <member name="T:ParserCore.ParserMatch">
             <summary>
             暂时未实现,难度较高,实现类似与正则表达式的状态机逻辑
             解析效率相对固定流程较低,但是易于读写和修改
            
             例解析一个类: n { loop{n=v;} }
             </summary>
        </member>
        <member name="T:ParserCore.Token">
            <summary>
            一个由文本内容解析成的标记
            </summary>
        </member>
        <member name="T:IJsonSerialize">
            <summary>
            对象序列化和反序列化后的回调接口
            </summary>
        </member>
        <member name="T:Json">
            <summary>
            <para>对于一些来源与接口和基类定义的对象,在序列化时会注入类型,便于反序列化时生成 </para>
            <para>在反序列化的基本识别中整数为int,带小数点为float  </para>
            <para>序列化生成的文本带有格式控制符</para>
            <para>当外部定义类型有名称空间时,需要注册,如: AssemblyUtil.RegType(typeof(ObservableCollection&lt;&gt;), "ObservableCollection");</para>
            <para>支持数组,泛型,以及泛型嵌套</para>
            <para>支持类型内部定义的类型</para>
            </summary>
        </member>
        <member name="T:Json.ObjectStyle">
            <summary>
            对象序列化的两中方式1.按字段2.按属性
            </summary>
        </member>
        <member name="F:Json.ObjectStyle.Field">
            <summary>
            对象按字段序列化和反序列化
            </summary>
        </member>
        <member name="F:Json.ObjectStyle.Property">
            <summary>
            对象按属性序列化和反序列化
            </summary>
        </member>
        <member name="M:Json.Deserialize(System.String,System.Type)">
            <summary>
            反序列化(content中含类型时不传type)
            </summary>
        </member>
        <member name="M:Json.TryDeserialize``1(System.String)">
            <summary>
            反序列化(content中不含类型)
            </summary>
        </member>
        <member name="M:Json.Deserialize``1(System.String)">
            <summary>
            反序列化(content中不含类型)
            </summary>
        </member>
        <member name="M:Json.Serialize(System.Object,Json.ObjectStyle,System.Boolean)">
            <summary>
            序列化
            </summary>
        </member>
        <member name="M:Json.Clone(System.Object,Json.ObjectStyle)">
            <summary>
            克隆对象
            </summary>
        </member>
        <member name="M:Json.Clone``1(``0,Json.ObjectStyle)">
            <summary>
            克隆对象
            </summary>
        </member>
        <member name="T:JsonParser">
            <summary>
            按类型解析
            1.基本数据类型
            2.枚举
            3.数组
            4.字典
            5.自定义类
            </summary>
        </member>
        <member name="M:JsonParser.TryParseValue(System.Type,System.Object@)">
            <summary>
            输出类型
            1.自定义类型
            2.整形数字为int
            3.浮点数字为float
            4.字符串为string
            5.布尔为bool
            </summary>
        </member>
        <member name="M:JsonParser.TryParseType(System.Type,System.Object@)">
            <summary>
            解析类型名,包含泛型,以及泛型嵌套类型<para/>
            1.  List&lt;T&gt;<para/>
            2. T() 数组<para/>
            3.  Dictionary&lt;Tkey,Tvalue&gt;<para/>
            4. T
            </summary>
        </member>
        <member name="M:JsonParser.TryParseObject(System.Type,System.Object@)">
            <summary>
            读取属性成员
            解析对象(Type){ var=value;...}
            </summary>
        </member>
        <member name="M:JsonParser.TryParseList(System.Type,System.Object@)">
            <summary>
            解析List(listType&lt;itemType&gt;)[ value,...]
            </summary>
        </member>
        <member name="M:JsonParser.TryParseArray(System.Type,System.Object@)">
            <summary>
            解析数组 T()[ value,...]
            </summary>
        </member>
        <member name="M:JsonParser.TryParseDictionary(System.Type,System.Object@)">
            <summary>
            解析字典(dicType&lt;keyType,valueType&gt;)
            { value:value,value:value...} -->
            </summary>
        </member>
        <member name="M:JsonSerialize.SerializeValue(System.Object,System.IO.StringWriter,System.Type,System.String,System.Boolean)">
            <summary>
            序列化任意一个对象
            </summary>
            <param name="obj">准备序列化的对象</param>
            <param name="sw">序列化字符流</param>
            <param name="inputType">输入类型</param>
            <param name="tab">换行时前面包含的制表符</param>
            <param name="inExpression">是否是表达式中的值,用于控制输出格式</param>
        </member>
        <member name="F:StringCompress.compressSize">
            <summary>
            超过这个尺寸的数据会被压缩
            </summary>
        </member>
        <member name="F:StringCompress.uncompressScale">
            <summary>
            解压时缓冲区以多大倍数的空间来接收数据
            </summary>
        </member>
        <member name="M:StringCompress.CheckCompress(System.String)">
            <summary>
            自动判定内容大小选择性压缩,返回首位表示数据是否有压缩<para/>
            主要应用于网络通信时
            </summary>
        </member>
        <member name="M:StringCompress.CheckUnCompress(System.Byte[])">
            <summary>
            根据首位表示数据是否有压缩,来选择性处理数据<para/>
            主要应用于网络通信时
            </summary>
        </member>
        <member name="M:StringCompress.Compress(System.Byte[])">
            <summary>  
            字符串压缩  
            </summary>  
        </member>
        <member name="M:StringCompress.Decompress(System.Byte[])">
            <summary>  
            字符串解压缩  
            </summary>  
        </member>
        <member name="T:AssemblyUtil">
            <summary>
            运算符扩展
            </summary>
            <summary>
            特性扩展类,提供
            1.在类定义中的查找特性
            2.获取类定义中的特性列表
            3.在对象所有成员中查找特定的特性,(每个成员最多只找出一个)返回列表
            4.返回某成员的特性列表
            5.在某成员中查找特性
            </summary>
            <summary>
            哈希类成id
            </summary>
            <summary>
            注册的类型不含泛型的派生类型(派生类型由MakeType合成)
            通过类名,在程序集中查询类
            通过成员名,查询FieldInfo
            
            类型注册的策略:
            为部分名称较长的类名定义一个简单名称,方便序列化和反序列化
            同时也可以支持不用注册,直接通过类型全名反射相应的类型
            </summary>
            <summary>
            通过类名,在程序集中查询类
            通过成员名,查询MethodInfo
            </summary>
            <summary>
            程序集相关接口
            </summary>
        </member>
        <member name="M:AssemblyUtil.Add(System.Object,System.Object)">
            <summary>
            调用a的+运算符函数执行计算
            </summary>
        </member>
        <member name="M:AssemblyUtil.Sub(System.Object,System.Object)">
            <summary>
            调用a的-运算符函数执行计算
            </summary>
        </member>
        <member name="M:AssemblyUtil.Multiply(System.Object,System.Object)">
            <summary>
            调用a的*运算符函数执行计算
            </summary>
        </member>
        <member name="M:AssemblyUtil.Division(System.Object,System.Object)">
            <summary>
            调用a的/运算符函数执行计算
            </summary>
        </member>
        <member name="M:AssemblyUtil.ImportCustomOperator``3(CalcOperator,System.Func{``0,``1,``2})">
            <summary>
            自定义运算方式
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetOperator(System.Type,System.String,System.Type)">
            <summary>
            获取类型中的运算重载函数
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreateInstance(System.String)">
            <summary>
            通过类名创建带默认构造的对象
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreateInstance``1(System.Type,System.Object[])">
            <summary>
            反射调用带参构造生成对象
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreateListElement(System.Collections.IList)">
            <summary>
            创建一个元素(List&lt;&gt;)
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreateArrayElement(System.Collections.IList)">
            <summary>
            创建一个元素([])
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreateInstance(System.Type,System.Object[])">
            <summary>
            反射调用带参构造生成对象,
            注:在ios平台上,由此函数创建对象的类,不能有名称空间,不然会抛找不到构造的异常
            </summary>
        </member>
        <member name="M:AssemblyUtil.CreatePrivateInstance(System.Type,System.Object[])">
            <summary>
            反射调用带参构造生成对象,
            注:在ios平台上,由此函数创建对象的类,不能有名称空间,不然会抛找不到构造的异常
            </summary>
        </member>
        <member name="M:AssemblyUtil.SetAttributeTarget(System.Attribute,System.Reflection.MemberInfo,System.Object)">
            <summary>
            向特性中注入它所修饰的成员所在的对象
            返回某成员的特性列表
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetCustomAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean,System.Object)">
            <summary>
            基础api扩展
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetCustomAttributes(System.Reflection.MemberInfo,System.Boolean,System.Object)">
            <summary>
            基础api扩展
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetCustomAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean,System.Object)">
            <summary>
            基础api扩展
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberAttribute``1(System.Reflection.MemberInfo,System.Boolean,System.Object)">
            <summary>
            在某成员中查找特性
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberAttributes``1(System.Reflection.MemberInfo,System.Boolean,System.Object)">
            <summary>
            返回某成员的特性列表
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetClassAttribute``1(System.Object,System.Boolean)">
            <summary>
            在类定义中的查找特性
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetClsssAttributes(System.Object,System.Boolean)">
            <summary>
            获取类定义中的特性
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberAttributesInObject``1(System.Object,System.Boolean)">
            <summary>
            在对象所有成员中查找特定的特性,(每个成员最多只找出一个)返回列表
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMethodsAttributesInType``1(System.Type,System.Boolean)">
            <summary>
            在类的所有静态方法中查找特定的特性,(每个成员最多只找出一个)返回列表
            </summary>
        </member>
        <member name="M:AssemblyUtil.InitHashMap(System.Type[])">
            <summary>
            建立hash映射
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetHashId(System.Type)">
            <summary>
            由类型获得哈希id
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetHashType(System.UInt16)">
            <summary>
            由哈希id获得类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.SetMemberValue(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            设置成员
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberValue(System.Object,System.String)">
            <summary>
            获取成员
            </summary>
        </member>
        <member name="M:AssemblyUtil.HasMember(System.Object,System.String)">
            <summary>
            对象是否有成员
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberValueByExpression(System.Object,System.String)">
            <summary>
            通过对象的成员表达式获取成员,形如:a.list[0].name
            </summary>
        </member>
        <member name="M:AssemblyUtil.MemberParser(System.String)">
            <summary>
            解析a.b.c得到一个对象
            或者一个数字或者字符串
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsFundamental(System.Type)">
            <summary>
            检查是不是基础类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsList(System.Type)">
            <summary>
            判定形如List&lt;T&gt;的类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsArray(System.Type)">
            <summary>
            判定形如T[]的类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsDictionary(System.Type)">
            <summary>
            判定形如Dictionary&lt;T1,T2&gt;的类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetType(System.String)">
            <summary>
            通过类型名的简写在注册的名称中查找类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsRegType(System.Type)">
            <summary>
            检查是不是一个合法的注册类型(普通类型,或者泛型定义类型)
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetName(System.Type)">
            <summary>
            获取类型全名,当类型已注册一个简单名称时返回这个名称
            </summary>
        </member>
        <member name="M:AssemblyUtil.RegType(System.Type,System.String)">
            <summary>
            注册类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.RegType(System.Type[])">
            <summary>
            注册类型,使之可以由GetTypeByName,GetNameByType获取
            </summary>
        </member>
        <member name="M:AssemblyUtil.Assign``1(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            为指定对象分配参数??
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMethodInfoDic(System.Type)">
            <summary>
            获取类型的成员信息字典
            </summary>
        </member>
        <member name="M:AssemblyUtil.CallMethodArgTypeByType(System.Type,System.Type)">
            <summary>
            传入的类型符合是否符合方法本身参数定义的类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.HasMethod(System.Type,System.String)">
            <summary>
            是否有方法
            </summary>
        </member>
        <member name="M:AssemblyUtil.SetCallBack(System.Object,System.String,System.Delegate)">
            <summary>
            设置对象的成员函数对象
            </summary>
        </member>
        <member name="M:AssemblyUtil.InvokeObjMethod(System.Object,System.String,System.Object[])">
            <summary>
            执行对象方法,可调私有方法
            可以有默认值,并支持重载函数 以及params的不定参数表
            </summary>
        </member>
        <member name="M:AssemblyUtil.InvokePrivateMethod(System.Object,System.String,System.Object[])">
            <summary>
            执行方法
            可以有默认值,并支持重载函数 以及params的不定参数表
            </summary>
        </member>
        <member name="M:AssemblyUtil.InvokeMethod(System.Object,System.String,System.Object[])">
            <summary>
            执行方法
            可以有默认值,并支持重载函数 以及params的不定参数表
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsEquation(System.String)">
            <summary>
            是一个赋值表达式
            </summary>
        </member>
        <member name="M:AssemblyUtil.EquationParser(System.String)">
            <summary>
            赋值表达式解析
            </summary>
        </member>
        <member name="M:AssemblyUtil.IsMethod(System.String)">
            <summary>
            是一个函数调用表达式
            形如a.b.c(xx,yy)
            </summary>
        </member>
        <member name="M:AssemblyUtil.MethodParser(System.String)">
            <summary>
            编译执行函数
            形式\(m.\)( \(v,\)v)
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetTypesByNamespace(System.String,System.Type[])">
            <summary>
            查找在某名称空间下的类型表
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetTypesByNamespace(System.String)">
            <summary>
            查找在名称空间下定义的所有的类型(只会匹配一个程序集)
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetTypesByNamespace(System.Reflection.Assembly,System.String)">
            <summary>
            在这个程序集下查找特定名称空间的所有类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.OnResolveAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            嵌入 dll解决方式
            </summary>
        </member>
        <member name="M:AssemblyUtil.CompileAndExec(System.String)">
            <summary>
            编译执行代码,返回结果
            </summary>
        </member>
        <member name="M:AssemblyUtil.NewAssembly(System.String)">
            <summary>
            编译
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            获取成员值<para/>
            如果尝试在获取属性中抛出异常,则返回null<para/>
            当需要获取静态成员时,obj传null
            </summary>
        </member>
        <member name="M:AssemblyUtil.SetValue(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
            设置成员
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMemberType(System.Reflection.MemberInfo)">
            <summary>
            获取成员类型
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetStaticMemberValue(System.Type,System.String)">
            <summary>
            获取静态成员
            </summary>
        </member>
        <member name="M:AssemblyUtil.GetMembers(System.Type,CqCore.SerializeTypeStyle,System.Reflection.BindingFlags)">
            <summary>
            获取类型的特定成员<para/>
            默认获取所有非静态成员<para/>
            主要提供给对象序列化时使用
            </summary>
        </member>
        <member name="T:CodeDomExpression">
            <summary>
            程序说明：C#动态编译计算表达式的值，是通过System.CodeDom.Compiler命名空间下的相关类来实现的,如：CSharpCodeProvider类。步骤如下：
            1.将表达式封装成为可编译的C#代码；
            2.动态编译C#代码，生成Assembly程序集。
            3.使用.NET反射调用方法计算表达式的值。
            </summary>
        </member>
        <member name="M:CodeDomExpression.Calculate(System.String)">
            <summary>
            算术表达式求结果
            </summary>
        </member>
        <member name="M:CodeDomExpression.DoCalculate(System.String)">
            <summary>
            计算表达式的值
            </summary>
            <param name="expression">表达式</param>
            <returns></returns>
        </member>
        <member name="M:CodeDomExpression.DoWrapCode(System.String)">
            <summary>
            封装C#代码
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:ISetCallBack">
            <summary>
            为实例中函数对象赋值的接口,主要应用于lua层面不一样的成员操作<para/>
            实现这个接口的类可以通过AssemblyUtil.SetMemberValue调用
            </summary>
        </member>
        <member name="T:ISetGetMemberValue">
            <summary>
            可由成员名称访问成员,主要应用于lua层面不一样的成员操作<para/>
            实现这个接口的类可以通过AssemblyUtil.SetMemberValue调用这个接口设置成员
            </summary>
        </member>
        <member name="T:IInvokeMethod">
            <summary>
            可由方法名称调用内部方法,主要应用于lua层面不一样的成员操作<para/>
            实现这个接口的类,可由AssemblyUtil.InvokeMethod访问接口
            </summary>
        </member>
        <member name="T:DoubleUtil">
            <summary>
            扩展带精度的判定
            </summary>
        </member>
        <member name="M:DoubleUtil.FloorByEpsilon(System.Double,System.Double)">
            <summary>
            有精度的向下取整,比如1.99999虽然向下取整,也应该是2,而不是1
            </summary>
        </member>
        <member name="M:DoubleUtil.EqualsByEpsilon(System.Double,System.Double,System.Double)">
            <summary>
            a==b
            a,b在误差Epsilon范围内视为相等
            </summary>
        </member>
        <member name="M:DoubleUtil.GreaterEqualsByEpsilon(System.Double,System.Double,System.Double)">
            <summary>
            带精度的判定a&gt;=b
            </summary>
        </member>
        <member name="M:DoubleUtil.LessEqualsByEpsilon(System.Double,System.Double,System.Double)">
            <summary>
            带精度的判定a&lt;=b
            </summary>
        </member>
        <member name="M:DoubleUtil.Dcmp(System.Double,System.Double)">
            <summary>
            在[-limit,limit]内视为0
            </summary>
        </member>
        <member name="M:DoubleUtil.EqualZero(System.Double,System.Double)">
            <summary>
            v在[-limit,limit]误差范围内返回true
            </summary>
        </member>
        <member name="M:ConvertUtil.ChangeType(System.Object,System.Type)">
            <summary>
            类型转换
            </summary>
        </member>
        <member name="M:ConvertUtil.ConvertType(System.Object,System.Type)">
            <summary>
            主要操作基本类型转换,比如int 转uint,float 转double之类
            也可以支持自定义类型,需要实现System.IConvertible接口
            </summary>
        </member>
        <member name="M:ConvertUtil.BaseChangeType``1(System.Object)">
            <summary>
            泛型转换
            </summary>
        </member>
        <member name="T:ListFind`1">
            <summary>
            主要用于优化对静态数据的查询,先生成查询数据,使用时0检索
            大数据列表检索器,用于不作变化的数据的快速查询
            对数据量大的表 形如List(Struct),建立Struct属性的查找索引表
            查询时0查询次数获取数据
            用法例:ListDataMgr.MakeQueryIndex(ConfigMgr_XX.instance);
            var v = ListDataMgr.Find&lt;Config_XX.RECORD&gt;("id", 5);
            var list = ListDataMgr.FindList&lt;Config_XX.RECORD&gt;("price", 10);
            </summary>
        </member>
        <member name="T:Singleton`1">
            <summary>
            单例不应由反射来调用构造
            </summary>
        </member>
        <member name="T:TorsionParser">
            <summary>
            按类型解析
            1.基本数据类型
            2.枚举
            3.数组
            4.字典
            5.自定义类
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseValue(System.Type,System.Object@)">
            <summary>
            输出类型
            1.自定义类型
            2.整形数字为int
            3.浮点数字为float
            4.字符串为string
            5.布尔为bool
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseType(System.Type,System.Object@)">
            <summary>
            解析类型名,包含泛型,以及泛型嵌套类型
            1.  List&lt;T&gt;
            2. T() 数组
            3.  Dictionary&lt;Tkey,Tvalue&gt;
            4. T
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseObject(System.Type,System.Object@)">
            <summary>
            读取字段成员
            解析对象(Type){ var=value;...}
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseList(System.Type,System.Object@)">
            <summary>
            解析List(listType&lt;itemType&gt;)[ value,...]
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseArray(System.Type,System.Object@)">
            <summary>
            解析数组 T()[ value,...]
            </summary>
        </member>
        <member name="M:TorsionParser.TryParseDictionary(System.Type,System.Object@)">
            <summary>
            解析字典(dicType&lt;keyType,valueType&gt;)
            { value:value,value:value...} -->
            </summary>
        </member>
        <member name="T:Torsion">
            <summary>
            <para>对于一些来源与接口和基类定义的对象,在序列化时会注入类型,便于反序列化时生成 </para>
            <para>在反序列化的基本识别中整数为int,带小数点为float  </para>
            <para>序列化生成的文本带有格式控制符</para>
            <para>当外部定义类型有名称空间时,需要注册,如: AssemblyUtil.RegType(typeof(ObservableCollection&lt;&gt;), "ObservableCollection");</para>
            <para>支持数组,泛型,以及泛型嵌套</para>
            <para>支持类型内部定义的类型</para>
            </summary>
        </member>
        <member name="T:Torsion.ObjectStyle">
            <summary>
            对象序列化的两中方式1.按字段2.按属性
            </summary>
        </member>
        <member name="F:Torsion.ObjectStyle.Field">
            <summary>
            对象按字段序列化和反序列化
            </summary>
        </member>
        <member name="F:Torsion.ObjectStyle.Property">
            <summary>
            对象按属性序列化和反序列化
            </summary>
        </member>
        <member name="M:Torsion.TryDeserialize(System.String,System.Type)">
            <summary>
            反序列化
            当反序列化失败时返回null
            </summary>
        </member>
        <member name="M:Torsion.Deserialize(System.String)">
            <summary>
            反序列化(content中含类型)
            </summary>
        </member>
        <member name="M:Torsion.Deserialize``1(System.String)">
            <summary>
            反序列化(content中不含类型)
            </summary>
        </member>
        <member name="M:Torsion.Deserialize(System.String,System.Type)">
            <summary>
            反序列化(content中含类型时不传type)
            </summary>
        </member>
        <member name="M:Torsion.TryDeserialize``1(System.String)">
            <summary>
            反序列化(content中不含类型)
            当反序列化失败时返回new T
            </summary>
        </member>
        <member name="M:Torsion.Serialize(System.Object,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            序列化
            当类型有SerializeByPropertyAttribute特性时,对属性做序列化
            </summary>
            <param name="obj">序列化对象</param>
            <param name="format">是否加上换行和制表符等,格式控制符</param>
            <param name="withObjType">是否包含序列化对象自己的类型</param>
            <param name="excludeRecursive">排除递归序列化(同一个自定义对象不会被重复序列化)</param>
            <param name="depth">序列化深度</param>
            <returns></returns>
        </member>
        <member name="M:Torsion.Clone(System.Object)">
            <summary>
            克隆对象
            </summary>
        </member>
        <member name="M:Torsion.Clone``1(``0)">
            <summary>
            克隆对象
            </summary>
        </member>
        <member name="M:Torsion.Equal(System.Object,System.Object)">
            <summary>
            对象序列化的数据内容相同
            </summary>
        </member>
        <member name="F:TorsionSerialize.excludeRecursive">
            <summary>
             排除递归序列化(同一个自定义对象不会被重复序列化)
            </summary>
        </member>
        <member name="M:TorsionSerialize.IsRecordingType(System.Type)">
            <summary>
            检查是不是一个需要保证不重复序列化的类型
            </summary>
        </member>
        <member name="F:TorsionSerialize.tblNum">
            <summary>
            当前深度
            </summary>
        </member>
        <member name="F:TorsionSerialize.depth">
            <summary>
            序列化深度
            </summary>
        </member>
        <member name="M:TorsionSerialize.#ctor(System.Boolean,System.Int32)">
            <summary>
            序列化生成器
            </summary>
            <param name="excludeRecursive">排除递归序列化(同一个自定义对象不会被重复序列化)</param>
            <param name="depth">序列化深度</param>
        </member>
        <member name="M:TorsionSerialize.SerializeValue(System.Object,System.Type,System.Boolean)">
            <summary>
            序列化任意一个对象
            </summary>
            <param name="obj">准备序列化的对象</param>
            <param name="inputType">输入类型</param>
            <param name="inExpression">是否是表达式中的值,用于控制输出格式</param>
        </member>
        <member name="F:TorsionSerialize.GetTbls">
            <summary>
            获取多个制表符
            </summary>
        </member>
        <member name="M:XmlUtil.Deserialize``1(System.String)">
            <summary>
            反序列化
            </summary>
        </member>
        <member name="M:XmlUtil.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            反序列化
            </summary>
        </member>
        <member name="M:XmlUtil.Serializer(System.Object)">
            <summary>
            序列化
            </summary>
            <param name="obj">对象</param>
            <returns></returns>
        </member>
        <member name="M:XmlUtil.XmlAnalysis(System.String,System.String)">
            <summary>
            摘要:获取对应XML节点的值
            </summary>
            <param name="stringRoot">XML节点的标记</param>
            <param name="xmlPath">XML内容</param>
            <returns>返回获取对应XML节点的值</returns>
        </member>
        <member name="T:Backtracking">
            <summary>
            回溯
            </summary>
        </member>
        <member name="M:Backtracking.Back">
            <summary>
            解析失败时回溯
            </summary>
        </member>
        <member name="T:EnumUtil">
            <summary>
            利用位操作来作状态记录的枚举
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumNames``1">
            <summary>
            获得枚举的值名字列表,有标签([EnumValue])的时候名字使用标签名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumNames(System.Type)">
            <summary>
            获得枚举的值名字列表,有标签([EnumValue])的时候名字使用标签名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumColors(System.Type)">
            <summary>
            获得枚举对应的html颜色列表,有标签([EnumValue])的时候名字使用标签名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumLabelName(System.Object)">
            <summary>
            获得某个枚举值的标注名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumLabelName(System.Type,System.Object)">
            <summary>
            获得某个枚举值的标注名字(EnumLabel),当没有定义标注时返回枚举定义的名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumLabelName``1(``0)">
            <summary>
            获得某个枚举值的标注名字
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumAttr``1(System.Type,System.Object)">
            <summary>
            获得枚举值的特性标签
            </summary>
        </member>
        <member name="M:EnumUtil.GetEnumAttr``1(System.Object)">
            <summary>
            获得枚举值的特性标签
            </summary>
        </member>
        <member name="M:EnumUtil.ConvertStringToEnum``1(System.String)">
            <summary>
            字符串转相应的枚举类型
            </summary>
        </member>
        <member name="M:EnumUtil.ToString``1(``0)">
            <summary>
            可打印叠加态
            </summary>
        </member>
        <member name="T:SysEnvironment">
            <summary>
            系统环境变量操作
            </summary>
        </member>
        <member name="M:SysEnvironment.GetSysEnvironmentByName(System.String)">
            <summary>
            获取系统环境变量
            </summary>
        </member>
        <member name="M:SysEnvironment.OpenSysEnvironment">
            <summary>
            打开系统环境变量注册表
            </summary>
            <returns>RegistryKey</returns>
        </member>
        <member name="M:SysEnvironment.SetSysEnvironment(System.String,System.String)">
            <summary>
            设置系统环境变量
            </summary>
            <param name="name">变量名</param>
            <param name="strValue">值</param>
        </member>
        <member name="M:SysEnvironment.CheckSysEnvironmentExist(System.String)">
            <summary>
            检测系统环境变量是否存在
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:SysEnvironment.SetPathAfter(System.String)">
            <summary>
            添加到PATH环境变量（会检测路径是否存在，存在就不重复）
            </summary>
        </member>
        <member name="T:FuncOut`2">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:FuncOut`3">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:FuncOut`4">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:FuncOutAll`3">
            <summary>
            所有参数是out的泛型委托
            </summary>
        </member>
        <member name="T:FuncOutAll`4">
            <summary>
            所有参数是out的泛型委托
            </summary>
        </member>
        <member name="T:FuncRef`2">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:FuncRef`3">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:FuncRef`4">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:FuncRefAll`3">
            <summary>
            所有参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:FuncRefAll`4">
            <summary>
            所有参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:ActionOut`1">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:ActionOut`2">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:ActionOut`3">
            <summary>
            最后一个参数是out的泛型委托
            </summary>
        </member>
        <member name="T:ActionRef`1">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:ActionRef`2">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:ActionRef`3">
            <summary>
            最后一个参数是ref的泛型委托
            </summary>
        </member>
        <member name="T:ListUtil">
            <summary>
            列表扩展
            </summary>
        </member>
        <member name="M:ListUtil.Equal``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            列表相等(顺序不一定相同)
            </summary>
        </member>
        <member name="M:ListUtil.MakeListByRemoveEqualItem``1(System.Collections.Generic.IList{``0})">
            <summary>
            去重复元素
            </summary>
        </member>
        <member name="M:ListUtil.GetItemByRound``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            循环获取列表元素<para/>
            当索引等于数量时返回列表第一个元素,当索引等于-1时返回列表最后一个元素,以此类推
            </summary>
        </member>
        <member name="M:ListUtil.GetItemByRange``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            范围获取列表元素
            当索引大于等于数量时返回列表最后一个元素,当索引小于0时返回列表第一个元素
            </summary>
        </member>
        <member name="M:ListUtil.Sort``1(System.Collections.Generic.List{``0},CqCore.ComparisonPriority{``0})">
            <summary>
            由成员计算得的优先级排序
            </summary>
        </member>
        <member name="M:ListUtil.Sort``1(System.Collections.Generic.List{``0},CqCore.ComparisonFloatPriority{``0})">
            <summary>
            由成员计算得的优先级排序
            </summary>
        </member>
        <member name="M:ListUtil.Swap``1(``0@,``0@)">
            <summary>
            交换
            </summary>
        </member>
        <member name="M:ListUtil.ListMove(System.Collections.IList,System.Object,System.Boolean)">
            <summary>
            移动数组中的元素
            </summary>
        </member>
        <member name="T:SingleUtil">
            <summary>
            扩展带精度的判定
            </summary>
        </member>
        <member name="M:SingleUtil.EqualsByEpsilon(System.Single,System.Single,System.Single)">
            <summary>
            a==b
            a,b在误差Epsilon范围内视为相等
            </summary>
        </member>
        <member name="M:SingleUtil.GreaterEqualsByEpsilon(System.Single,System.Single,System.Single)">
            <summary>
            带精度的判定a&gt;=b
            </summary>
        </member>
        <member name="M:SingleUtil.LessEqualsByEpsilon(System.Single,System.Single,System.Single)">
            <summary>
            带精度的判定a&lt;=b
            </summary>
        </member>
        <member name="M:SingleUtil.Dcmp(System.Single,System.Single)">
            <summary>
            在[-limit,limit]内视为0
            </summary>
        </member>
        <member name="M:SingleUtil.EqualZero(System.Single,System.Single)">
            <summary>
            v在[-limit,limit]误差范围内返回true
            </summary>
        </member>
        <member name="T:NetMQ.CustomDate">
            <summary>
             .net开发中计算的都是标准时区的差，但java的解析时间跟时区有关，
             而我们的java服务器系统时区不是标准时区，解析时间会差8个小时。
             传入java格式的(格林尼治时间)
            </summary>
        </member>
        <member name="M:NetMQ.CustomDate.op_Implicit(NetMQ.CustomDate)~System.String">
            <summary>
            隐式强转
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TimeUtil.SolarToChineseLunisolarDate(System.DateTime)">
            <summary>
            公历转为农历的函数
            </summary>
            <remarks>作者：DeltaCat</remarks>
            <example>网址：http://www.zu14.cn</example>
            <param name="solarDateTime">公历日期</param>
            <returns>农历的日期</returns>
        </member>
        <member name="M:TimeUtil.GetBirthdays(System.DateTime,System.Int32)">
            <summary>
            传入出生日期,获取百岁以内生日新旧历与出生时相同的年龄列表
            </summary>
        </member>
        <member name="P:TimeUtil.NowVersion">
            <summary>
            时间转为版本格式,形如: 2019.05.23.1201
            </summary>
        </member>
        <member name="P:TimeUtil.NowVersion3">
            <summary>
            时间转为版本格式,形如: 2019.0523.1201
            </summary>
        </member>
        <member name="F:TimeUtil.dt_1970_1_1">
            <summary>
            1970-1-1
            </summary>
        </member>
        <member name="F:TimeUtil.CurrentTimeZone_dt_1970_1_1">
            <summary>
            当前时区的1970_1_1
            </summary>
        </member>
        <member name="F:TimeUtil.second">
            <summary>
            1秒
            </summary>
        </member>
        <member name="F:TimeUtil.CurrentTimeZone">
            <summary>
            当前时区
            </summary>
        </member>
        <member name="M:TimeUtil.ToLocalTime(System.Int64)">
            <summary>
            时间戳转本地时间<para/>
            由1970至今的毫秒数返回本地带时区的DateTime
            </summary>
        </member>
        <member name="M:TimeUtil.ToUnix_timestamp_long(System.DateTime)">
            <summary>
            时间戳(毫秒)<para/>
            由本地时区时间DateTime返回格林时间1970,1,1至今的毫秒数
            </summary>
        </member>
        <member name="M:TimeUtil.ToUnix_timestamp(System.DateTime)">
            <summary>
            时间戳(秒)
            由本地时区时间DateTime返回格林时间1970,1,1至今的秒数
            </summary>
        </member>
        <member name="P:TimeUtil.ZoneTimeOffect">
            <summary>
            时差,对中国来说是28800,000毫秒
            </summary>
        </member>
        <member name="P:TimeUtil.Unix_timestamp">
            <summary>
            当前时间戳(秒)
            </summary>
        </member>
        <member name="P:TimeUtil.Unix_timestamp_long">
            <summary>
            当前时间戳(毫秒)
            </summary>
        </member>
        <member name="M:TimeUtil.TimeSpanFormat(System.Int32)">
            <summary>
            传入两个时刻相减的秒数 返回时间长度(string) 形如00:02:51
            </summary>
        </member>
        <member name="M:TimeUtil.TimeSpanFormat(System.Int32,System.String,System.String)">
            <summary>
            传入两个时刻相减的秒数 返回时间长度(string) 形如00:02:51 
            format="HH:mm:ss"
            style 可选D2 null
            </summary>
        </member>
        <member name="M:TimeUtil.GetTimeStringByDate(System.DateTime,System.String)">
            <summary>
            本地时刻
            yyyy-MM-dd HH:mm:ss
            </summary>
        </member>
        <member name="M:TimeUtil.GetTimeStringBySecond(System.Int32,System.String)">
            <summary>
            时刻
            yyyy-MM-dd HH:mm:ss
            </summary>
        </member>
        <member name="M:TimeUtil.TimeFormat(System.Int32,System.String)">
            <summary>
            时刻
            </summary>
        </member>
        <member name="M:CustomHash.FNVHash(System.String)">
            <summary>
            32位FNV算法
            </summary>
        </member>
        <member name="M:CustomHash.BKDRHash(System.String)">
            <summary>
             BKDR Hash   
            </summary>
        </member>
        <member name="M:CustomHash.CRCHash(System.String)">
            <summary>
            CRCHash
            </summary>
        </member>
        <member name="M:CompressCRC.compress(System.Byte[])">
            <summary>
            压缩
            </summary>
        </member>
        <member name="M:CompressCRC.unCompress(System.Byte[])">
            <summary>
            解压
            </summary>
        </member>
        <member name="T:CRC16">
            <summary>
            循环冗余校验码Cyclic Redundancy Check
            </summary>
        </member>
        <member name="F:CRC16.crctab">
             <summary>        
             CRCTAB 表   
            
             
             </summary> 
        </member>
        <member name="M:CRC16.xcrc(System.UInt16,System.Byte)">
            <summary>       
            CRC校验公式  
            </summary>        
            <param name="crc">CRC</param>        
            <param name="cp">发送的数据序列</param>       
            <returns>新CRC</returns>       
        </member>
        <member name="M:CRC16.ConCRC(System.Byte[]@,System.Int32)">
            <summary> 
            添加CRC校验字
            </summary>  
            <param name="bufin">信息串</param>  
            <param name="n">不包括校验字的串总长度
            </param>      
        </member>
        <member name="M:CRC16.DataCRC(System.Byte[]@,System.Int32)">
            <summary>  
            CRC数据验证 
            </summary>        
            <param name="bufout">信息串</param>       
            <param name="count">接收数据总长度</param>     
            <returns>true:校验成功,false:校验失败</returns>     
        </member>
        <member name="T:Cryptographic">
            <summary>
            各种加密和解密方式
            </summary>
        </member>
        <member name="M:Cryptographic.CQEncrypt(System.Byte[],System.Byte[])">
            <summary>
            2次偏移加密算法
            </summary>
            <param name="inputByteArray"></param>
            <param name="keyAry"></param>
            <returns></returns>
        </member>
        <member name="M:Cryptographic.CQDecrypt(System.Byte[],System.Byte[])">
            <summary>
            2次偏移解密算法
            </summary>
            <param name="inputByteArray"></param>
            <param name="keyAry"></param>
            <returns></returns>
        </member>
        <member name="M:Cryptographic.AESEncrypt(System.Byte[],System.String)">
            <summary>
            AES加密算法
            </summary>
            <param name="inputByteArray">明文字符串</param>
            <param name="strKey">密钥</param>
            <returns>返回加密后的密文字节数组</returns>
        </member>
        <member name="M:Cryptographic.AESDecrypt(System.Byte[],System.String)">
            <summary>
            AES解密算法
            </summary>
            <param name="cipherText">密文字节数组</param>
            <param name="strKey">密钥</param>
            <returns>返回解密后的字符串</returns>
        </member>
        <member name="M:Cryptographic.EncryptDES(System.Byte[],System.String,System.String)">
            <summary>
            加密字节流
            </summary>
            <param name="inData">原始字节流</param>
            <param name="key"></param>
            <param name="iv"></param>
            <returns></returns>
        </member>
        <member name="M:Cryptographic.DecryptDES(System.Byte[],System.String,System.String)">
            <summary>
            解密字节流
            </summary>
            <param name="encryptedData">加密的字节流</param>
            <param name="key"></param>
            <param name="iv"></param>
            <returns></returns>
        </member>
        <member name="M:Cryptographic.DESEncrypt(System.String,System.String,System.String)">
            <summary>
            DES加密方法
            </summary>
            <param name="strPlain">明文</param>
            <param name="strDESKey">密钥</param>
            <param name="strDESIV">向量</param>
            <returns>密文</returns>
        </member>
        <member name="M:Cryptographic.DESDecrypt(System.String,System.String,System.String)">
            <summary>
            DES解密方法
            </summary>
            <param name="strCipher">密文</param>
            <param name="strDESKey">密钥</param>
            <param name="strDESIV">向量</param>
            <returns>明文</returns>
        </member>
        <member name="M:Zip.Compress(System.String)">
            <summary>
            压缩字符串
            maxCompressionRatio用于确定压缩缓冲区的大小.
            </summary>
        </member>
        <member name="M:Zip.Decompress(System.String)">
            <summary>
            解压缩字符串
            maxCompressionRatio最大压缩率,用于确定解压缓冲区的大小.
            </summary>
        </member>
        <member name="M:Zip.Compress(System.Byte[])">
            <summary>
            GZip压缩
            </summary>
        </member>
        <member name="M:Zip.Decompress(System.Byte[])">
            <summary>
            ZIP解压
            </summary>
        </member>
        <member name="M:Zip.Compress(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            压缩字节数组
            </summary>
        </member>
        <member name="M:Zip.Decompress(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            解压缩字节数组
            </summary>
        </member>
    </members>
</doc>
